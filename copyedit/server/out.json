[
{"paragraph": "                                ~\\subref{#2}}", "errors": [], "file": "../../thesis/template/template.tex"}
,
{"paragraph": "                                     \n                                                      }%\n                                               }}\n                                                        }}}                                                                                                       ,mathescape]{#1}}", "errors": [{"i": [32, 3, 163, 308, "mathescape"], "s": ["math escape", "math-escape"], "e": "spell"}], "file": "../../thesis/template/template.tex"}
,
{"paragraph": "\\title{Parallelizing the Browser: Synthesis and Optimization of Parallel Tree Traversals}\n                          \n                     \n                 \n                             \n                                 \n                                                                                              ", "errors": [{"i": [[66, 0, 7, 7, "Parallelizing"], [66, 0, 21, 21, "the"], [66, 0, 25, 25, "Browser"], [66, 0, 34, 34, "Synthesis"], [66, 0, 44, 44, "and"], [66, 0, 48, 48, "Optimization"], [66, 0, 61, 61, "of"], [66, 0, 64, 64, "Parallel"], [66, 0, 73, 73, "Tree"], [66, 0, 78, 78, "Traversals"]], "s": " Parallelizing the Browser: Synthesis and Optimization of Parallel Tr \bee Traversals.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 13\r\n\tUnique linkage, cost vector = (UNUSED=14 DIS=0 AND=0 LEN=0)\r\n\r\n[parallelizing] [the] [Browser] [:] [Synthesis] [and] [Optimization] [of] \r\n\r\n\r\n[Parallel] [Tree] [Traversals] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/template.tex"}
,
{"paragraph": "From low-power phones to speed-hungry data visualizations, web browsers need a performance boost. Parallelization is an attractive opportunity because commodity client devices already feature multicore, subword-SIMD, and GPU hardware. However, a typical webpage will not strongly benefit from modern hardware because browsers were only designed for sequential execution. We therefore need to redesign browsers to be parallel. This thesis focuses on a browser component that we found to be particularly challenging to implement: the layout engine. ", "errors": [{"i": [10, 0, 203, 203, "subword-SIMD"], "s": [], "e": "spell"}], "file": "../../thesis/template/abstract.tex"}
,
{"paragraph": "We address layout engine implementation by identifying its surprising connection with attribute grammars and then solving key ensuing challenges:\n                 \n      We show how layout engines, both for documents and data visualization, can often be functionally specified in our extended form of attribute grammars. \n      We introduce a synthesizer that automatically schedules an attribute grammar as a composition of parallel tree traversals. Notably, our synthesizer is fast, simple to extend, and finds schedules that assist aggressive code generation.\n      We make editing parallel code safe by introducing a simple programming construct for partial behavioral specification: schedule sketching. \n      We optimize tree traversals for SIMD, MIMD, and GPU architectures at tree load time through novel optimizations for data representation and task scheduling.\n               \nPut together, we generated a parallel CSS document layout engine that can mostly render complex sites such as Wikipedia. Furthermore, we scripted data visualizations that support interacting with over 100,000 data points in real time.", "errors": [{"i": [12, 7, 110, 998, "Wikipedia"], "s": [], "e": "spell"}], "file": "../../thesis/template/abstract.tex"}
,
{"paragraph": "                  \n          \n              \nTo You   vspace{12pt}\nHey you! out there in the cold \nGetting lonely, getting old, can you feel me \nHey you! Standing in the aisles \nWith itchy feet and fading smiles, can you feel me \nHey you! don't help them to bury the live \nDon't give in without a fight. \n            \n          \n                ", "errors": [{"i": [97, 3, 9, 54, "vspace"], "s": ["space", "vs pace", "vs-pace"], "e": "spell"}, {"i": [97, 3, 18, 63, "pt"], "s": ["apt", "at", "et", "ft", "it", "opt", "pa", "pat", "PB", "PC", "PDT", "pet", "Ph", "pH", "pi", "pit", "PM", "pot", "PST", "PTA", "put", "st"], "e": "spell"}, {"i": [97, 7, 5, 183, "itchy"], "s": ["itch"], "e": "spell"}], "file": "../../thesis/template/template.tex"}
,
{"paragraph": "                        \nI want to thank my advisor for advising me.\n                      ", "errors": [], "file": "../../thesis/template/template.tex"}
,
{"paragraph": "\\subsection{Why Parallel Computing}\n\\subsection{Why Mechanize Layout}\n\\subsection{Approach}", "errors": [{"i": [[3, 0, 12, 12, "Why"], [3, 0, 16, 16, "Parallel"], [3, 0, 25, 25, "Computing"]], "s": " Why Parallel Computing.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 5\r\n\tUnique linkage, cost vector = (UNUSED=6 DIS=0 AND=0 LEN=0)\r\n\r\n[why] [Parallel] [Computing] [.] \r\n\r\n", "e": "gram"}, {"i": [[3, 1, 12, 48, "Why"], [3, 1, 16, 52, "Mechanize"], [3, 1, 26, 62, "Layout"]], "s": " Why Mechanize Layout.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 5\r\n\tUnique linkage, cost vector = (UNUSED=6 DIS=0 AND=0 LEN=0)\r\n\r\n[why] [Mechanize] [Layout] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap1.tex"}
,
{"paragraph": "\\section{Mechanizing Layout Languages with Sugared Attribute Grammars}", "errors": [{"i": [[7, 0, 9, 9, "Mechanizing"], [7, 0, 21, 21, "Layout"], [7, 0, 28, 28, "Languages"], [7, 0, 38, 38, "with"], [7, 0, 43, 43, "Sugared"], [7, 0, 51, 51, "Attribute"], [7, 0, 61, 61, "Grammars"]], "s": " Mechanizing Layout Languages with Sugared Attribute Grammars.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 9\r\n\tUnique linkage, cost vector = (UNUSED=10 DIS=0 AND=0 LEN=0)\r\n\r\n[mechanizing] [Layout] [Languages] [with] [Sugared] [Attribute] [Grammars] \r\n\r\n\r\n[.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap1.tex"}
,
{"paragraph": "\\section{A Scheduling Language for Structuring and Verifying Parallel Traversals}\n\\section{Controlling Automatic Parallelization through Schedule Sketches}\n\\section{The Design of a Parallel Schedule Synthesizer}\n\\section{Optimizing Parallel Tree Traversals for Commodity Architectures}", "errors": [{"i": [[10, 0, 9, 9, "A"], [10, 0, 11, 11, "Scheduling"], [10, 0, 22, 22, "Language"], [10, 0, 31, 31, "for"], [10, 0, 35, 35, "Structuring"], [10, 0, 47, 47, "and"], [10, 0, 51, 51, "Verifying"], [10, 0, 61, 61, "Parallel"], [10, 0, 70, 70, "Traversals"]], "s": " A Scheduling Language for Structuring and Verifying Parallel Travers \bals.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 11\r\n\tUnique linkage, cost vector = (UNUSED=12 DIS=0 AND=0 LEN=0)\r\n\r\n[a] [Scheduling] [Language] [for] [Structuring] [and] [Verifying] [Parallel] \r\n\r\n\r\n[Traversals] [.] \r\n\r\n", "e": "gram"}, {"i": [[10, 1, 9, 91, "Controlling"], [10, 1, 21, 103, "Automatic"], [10, 1, 31, 113, "Parallelization"], [10, 1, 47, 129, "through"], [10, 1, 55, 137, "Schedule"], [10, 1, 64, 146, "Sketches"]], "s": " Controlling Automatic Parallelization through Schedule Sketches.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 8\r\n\tUnique linkage, cost vector = (UNUSED=9 DIS=0 AND=0 LEN=0)\r\n\r\n[controlling] [Automatic] [Parallelization] [through] [Schedule] [Sketches] \r\n\r\n\r\n[.] \r\n\r\n", "e": "gram"}, {"i": [[10, 2, 9, 165, "The"], [10, 2, 13, 169, "Design"], [10, 2, 20, 176, "of"], [10, 2, 23, 179, "a"], [10, 2, 25, 181, "Parallel"], [10, 2, 34, 190, "Schedule"], [10, 2, 43, 199, "Synthesizer"]], "s": " The Design of a Parallel Schedule Synthesizer.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 9\r\n\tUnique linkage, cost vector = (UNUSED=10 DIS=0 AND=0 LEN=0)\r\n\r\n[the] [Design] [of] [a] [Parallel] [Schedule] [Synthesizer] [.] \r\n\r\n", "e": "gram"}, {"i": [[10, 3, 9, 221, "Optimizing"], [10, 3, 20, 232, "Parallel"], [10, 3, 29, 241, "Tree"], [10, 3, 34, 246, "Traversals"], [10, 3, 45, 257, "for"], [10, 3, 49, 261, "Commodity"], [10, 3, 59, 271, "Architectures"]], "s": " Optimizing Parallel Tree Traversals for Commodity Architectures.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 9\r\n\tUnique linkage, cost vector = (UNUSED=10 DIS=0 AND=0 LEN=0)\r\n\r\n[optimizing] [Parallel] [Tree] [Traversals] [for] [Commodity] [Architectures] \r\n\r\n\r\n[.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap1.tex"}
,
{"paragraph": "\\section{Collaborators and Publications}", "errors": [{"i": [[15, 0, 9, 9, "Collaborators"], [15, 0, 23, 23, "and"], [15, 0, 27, 27, "Publications"]], "s": " Collaborators and Publications.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 5\r\n\tUnique linkage, cost vector = (UNUSED=6 DIS=0 AND=0 LEN=0)\r\n\r\n[Collaborators] [and] [Publications] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap1.tex"}
,
{"paragraph": "                                                        \n\\section{Motivation and Approach}", "errors": [{"i": [[1, 1, 9, 66, "Motivation"], [1, 1, 20, 77, "and"], [1, 1, 24, 81, "Approach"]], "s": " Motivation and Approach.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 5\r\n\tUnique linkage, cost vector = (UNUSED=6 DIS=0 AND=0 LEN=0)\r\n\r\n[motivation] [and] [Approach] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "We start by examining challenges for building layout languages and our high-level solution of automation through attribute grammars.  Throughout this and the remaining chapters, we focus on the design and implementation of one simple layout widget. We will show how our support of it generalizes to common layout languages and, more generally, computations over trees.", "errors": [], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsection{Important properties for layout languages and others}\nLayout languages are some of the most common -- for one gauge, there are over 634 million websites live in 2012, with 51 million added that year~                                                                                            . Beyond the CSS and HTML languages used for webpage layout, designers also use       ~[[CITE]] for document layout, D3~[[CITE]] for data visualization, Swing~[[Swing]] for GUI layout, and even specialize within these domains such as by using markdown for text. ", "errors": [{"i": [6, 1, 90, 156, "websites"], "s": ["web sites", "web-sites"], "e": "spell"}, {"i": [6, 1, 480, 546, "markdown"], "s": ["mark down", "mark-down"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Popular layout languages foster designer productivity by providing abstractions that are rich and numerous.\nThe alternative is analogous to asking a programmer to write in a low-level language such as assembly: designers should not manually specify, for each element, the position on a canvas and the style. Instead, layout languages resemble constraint systems where designers  declare high-level properties. For example, the high-level program                    states that the words              and              should be rendered, and word              should follow line-wrapping rules for its positioning after             . Layout languages may provide quite complicated constraints -- for example, most document layout languages resort to defining their line wrapping rule  in a flexible low-level language. Likewise, they may provide many featuress, such as in the 250+ pages of rules for the CSS language. Adding to the sophistication, many languages support designers adding their own constraints, such as through macros in       ,  percentage constraints in CSS, and arbitrary functions in Adobe Flex~[[CITE]]. ", "errors": [{"i": [10, 1, 742, 850, "featuress"], "s": ["features"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "The richness of popular layout languages comes at the cost of of complicating their design and implementation:", "errors": [{"i": [[13, 0, 0, 0, "The"], [13, 0, 4, 4, "richness"], [13, 0, 13, 13, "of"], [13, 0, 16, 16, "popular"], [13, 0, 24, 24, "layout"], [13, 0, 31, 31, "languages"], [13, 0, 41, 41, "comes"], [13, 0, 47, 47, "at"], [13, 0, 50, 50, "the"], [13, 0, 54, 54, "cost"], [13, 0, 59, 59, "of"], [13, 0, 62, 62, "of"], [13, 0, 65, 65, "complicating"], [13, 0, 78, 78, "their"], [13, 0, 84, 84, "design"], [13, 0, 91, 91, "and"], [13, 0, 95, 95, "implementation"]], "s": " The richness of popular layout languages comes at the cost of of com \bplicating their design and implementation:.\r\nNo complete linkages found.\r\nFound 16 linkages (16 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=0 AND=0 LEN=30)\r\n\r\n    +---------------------------------------------------------------------\r\n    |              +--------------------Ss--------------------+           \r\n    +------Wd------+      +------------Jp-----------+         |     +---Jp\r\n    |      +--Dmu--+--Mp--+     +----A----+----AN---+         +-MVp-+  +-D\r\n    |      |       |      |     |         |         |         |     |  |  \r\nLEFT-WALL the richness.n of popular.a layout.n languages.n comes.v at the \r\n\r\n\r\nXp--------------------------------------------------------------------+\r\n                                                                      |\r\n---+                  +--------Os-------+                             |\r\n*u-+----Mp---+---Mgp--+         +--D*u--+                             |\r\n   |         |        |         |       |                             |\r\ncost.n [of] of complicating.v their design.n and implementation.n [:] . \r\n\r\n\r\n    +---------------------------------------------------------------------\r\n    |              +--------------------Ss--------------------+           \r\n    +------Wd------+      +------------Jp-----------+         |     +---Jp\r\n    |      +--Dmu--+--Mp--+     +----A----+----AN---+         +-MVp-+  +-D\r\n    |      |       |      |     |         |         |         |     |  |  \r\nLEFT-WALL the richness.n of popular.a layout.n languages.n comes.v at the \r\n\r\n\r\nXp--------------------------------------------------------------------+\r\n                                                                      |\r\n---+                  +----------------Os----------------+            |\r\n*u-+----Mp---+---Mgp--+         +-----------D*u----------+            |\r\n   |         |        |         |                        |            |\r\ncost.n [of] of complicating.v their design.n and implementation.n [:] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "               \n      \\textbf{Safe semantics.} Does every input layout have exactly one unique rendering? Are the constraints restricted enough such that an efficient implementation is feasible for low-power devices, big data sets, and fast animation? When a feature is added, does it conflict with anything of the above properties? We want an automated way to verify such properties.\n      \\textbf{Safe implementation.} As a layout language grows in popularity, it grows in features. Likewise, developers will port it to many platforms and optimize it, and in cases such as CSS, reimplement it from scratch. Does the implementation conform to the intended semantics? Conformance bugs for CSS plague developers~[[CITE]], and failures to match {      }'s semantics have killed multiple attempts to modernize the implementation. We want an automated way to ensure that the implementation matches the specification.\n      \\textbf{Advanced implementation.} Layout languages tend to add feature as they evolve. However, the implementation of each feature also has demands that increase with time: improved speed and memory footprint, better debugging support, etc. Browser layout engines for CSS are currently over 100,000 lines of optimized C++ code, and most rich layout languages thus far have resisted parallelization. We want automation techniques to lower the implementation burden and more aggressively target those goals.\n             ", "errors": [{"i": [[15, 1, 236, 252, "When"], [15, 1, 241, 257, "a"], [15, 1, 243, 259, "feature"], [15, 1, 251, 267, "is"], [15, 1, 254, 270, "added"], [15, 1, 261, 277, "does"], [15, 1, 266, 282, "it"], [15, 1, 269, 285, "conflict"], [15, 1, 278, 294, "with"], [15, 1, 283, 299, "anything"], [15, 1, 292, 308, "of"], [15, 1, 295, 311, "the"], [15, 1, 299, 315, "above"], [15, 1, 305, 321, "properties"]], "s": " When a feature is added, does it conflict with anything of the above \b properties?\r\nNo complete linkages found.\r\nFound 4 linkages (1 had no P.P. violations) at null count 2\r\n\tUnique linkage, cost vector = (UNUSED=2 DIS=3 AND=0 LEN=26)\r\n\r\n    +--------------------------------------------------Xp-------------\r\n    +------------------Xx-----------------+                           \r\n    +--------Wd--------+                  |    +----I*d----+          \r\n    |            +--Ds-+---Ss--+-Pvf-+    +-Qd-+-SIs+      +--MVp--+--\r\n    |            |     |       |     |    |    |    |      |       |  \r\nLEFT-WALL [when] a feature.n is.v added.v , does.v it conflict.v with \r\n\r\n\r\n-------------------------------------+\r\n                                     |\r\n          +---------Jp--------+      |\r\nJs--+--Mp-+  +-------Dmc------+      |\r\n    |     |  |                |      |\r\nanything of the [above] properties.n ? \r\n\r\n", "e": "gram"}, {"i": [[15, 2, 14, 399, "Safe"], [15, 2, 19, 404, "implementation"]], "s": " Safe implementation.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 4\r\n\tUnique linkage, cost vector = (UNUSED=5 DIS=0 AND=0 LEN=0)\r\n\r\n[Safe] [implementation] [.] \r\n\r\n", "e": "gram"}, {"i": [[15, 3, 14, 927, "Advanced"], [15, 3, 23, 936, "implementation"]], "s": " Advanced implementation.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 4\r\n\tUnique linkage, cost vector = (UNUSED=5 DIS=0 AND=0 LEN=0)\r\n\r\n[Advanced] [implementation] [.] \r\n\r\n", "e": "gram"}, {"i": [[15, 3, 40, 953, "Layout"], [15, 3, 47, 960, "languages"], [15, 3, 57, 970, "tend"], [15, 3, 62, 975, "to"], [15, 3, 65, 978, "add"], [15, 3, 69, 982, "feature"], [15, 3, 77, 990, "as"], [15, 3, 80, 993, "they"], [15, 3, 85, 998, "evolve"]], "s": " Layout languages tend to add feature as they evolve.\r\nNo complete linkages found.\r\nFound 16 linkages (16 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=0 AND=0 LEN=11)\r\n\r\n    +------------------------------------Xp-----------------------------------\r\n    +---------Wd--------+                                                     \r\n    |         +----AN---+----Sp---+--TO-+--I-+------MVs------+-Cs-+--Sp--+    \r\n    |         |         |         |     |    |               |    |      |    \r\nLEFT-WALL layout.n languages.n tend.v to.r add.v [feature] as.p they evolve.v \r\n\r\n\r\n+\r\n|\r\n|\r\n|\r\n. \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "              \n          \n\\includegraphics[trim=0 0 0 0,clip,width=1.0\\columnwidth]{chapter2/architecture}\n\\caption{\\textbf{Layout engine architecture.} }\n                        \n            ", "errors": [{"i": [[22, 3, 17, 124, "Layout"], [22, 3, 24, 131, "engine"], [22, 3, 31, 138, "architecture"]], "s": " Layout engine architecture.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 5\r\n\tUnique linkage, cost vector = (UNUSED=6 DIS=0 AND=0 LEN=0)\r\n\r\n[Layout] [engine] [architecture] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Our idea is to declaratively specify layout languages and automatically compile them into an efficient implementation. At runtime, an instance of layout will be processed through the previously generated layout engine (Figure~\\ref{fig:architecture}). The compiler is responsible for checking the semantics of the layout features and, by construction, provides a correct implementation. Furthermore, instead of manually optimizing the code for every individual feature, language designers instead write generic compiler optimizations. As a similar implementation benefit, we automatically target multiple platforms for the same layout language, such as scripting languages in order to use their debuggers, and multicore and GPU languages to gain magnitudes of speedups.", "errors": [{"i": [[29, 0, 119, 119, "At"], [29, 0, 122, 122, "runtime"], [29, 0, 131, 131, "an"], [29, 0, 134, 134, "instance"], [29, 0, 143, 143, "of"], [29, 0, 146, 146, "layout"], [29, 0, 153, 153, "will"], [29, 0, 158, 158, "be"], [29, 0, 161, 161, "processed"], [29, 0, 171, 171, "through"], [29, 0, 179, 179, "the"], [29, 0, 183, 183, "previously"], [29, 0, 194, 194, "generated"], [29, 0, 204, 204, "layout"], [29, 0, 211, 211, "engine"], [29, 0, 218, 218, "(Figure"], [29, 0, 231, 231, "fig"], [29, 0, 235, 235, "architecture"], [29, 0, 248, 248, ")"]], "s": " At runtime, an instance of layout will be processed through the prev \biously generated layout engine (Figure~\\ref{fig:architecture).\r\nNo complete linkages found.\r\nFound 4 linkages (4 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=4 AND=0 LEN=40)\r\n\r\n    +--------------------------------------------------------------\r\n    +----------------------Wd---------------------+                \r\n    |              +--------------COp-------------+                \r\n    |              |        +----------Ds---------+                \r\n    |              +--Xc-+  |      +------AN------+---Ss--+--Ix-+--\r\n    |              |     |  |      |              |       |     |  \r\nLEFT-WALL [at] runtime.a , an instance.n [of] layout.n will.v be.v \r\n\r\n\r\n------------------Xp-------------------------------------------------\r\n                +----------------------Js---------------------+      \r\n                |      +------------------Ds------------------+------\r\n-Pv--+----MVp---+      |       +----Em----+-----A----+---AN---+    +-\r\n     |          |      |       |          |          |        |    | \r\nprocessed.v through.r the previously generated.v layout.n engine.n ( \r\n\r\n\r\n-------------------------------+\r\n                               |\r\n                               |\r\n---MXs--------+                |\r\n------Xd------+------Xc------+ |\r\n              |              | |\r\nFigure~\\ref{fig:architecture ) . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[29, 0, 386, 386, "Furthermore"], [29, 0, 399, 399, "instead"], [29, 0, 407, 407, "of"], [29, 0, 410, 410, "manually"], [29, 0, 419, 419, "optimizing"], [29, 0, 430, 430, "the"], [29, 0, 434, 434, "code"], [29, 0, 439, 439, "for"], [29, 0, 443, 443, "every"], [29, 0, 449, 449, "individual"], [29, 0, 460, 460, "feature"], [29, 0, 469, 469, "language"], [29, 0, 478, 478, "designers"], [29, 0, 488, 488, "instead"], [29, 0, 496, 496, "write"], [29, 0, 502, 502, "generic"], [29, 0, 510, 510, "compiler"], [29, 0, 519, 519, "optimizations"]], "s": " Furthermore, instead of manually optimizing the code for every indiv \bidual feature, language designers instead write generic compiler optimizations.\r\nNo complete linkages found.\r\nFound 52 linkages (52 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=2 AND=0 LEN=75)\r\n\r\n    +---------------------------------------------------------------------\r\n    +----------------------------------------------------------Wd---------\r\n    |          +-----------------------------------------------------CO---\r\n    |          |                 +----------------------------------------\r\n    |          |                 +-----------------------------------Xc---\r\n    |          |                 |                +--------MVp--------+---\r\n    |          |                 +-------Mgp------+------Os-----+     |   \r\n    |          +--Xc--+    +IDBBX+     +----Em----+       +-D*u-+     |   \r\n    |          |      |    |     |     |          |       |     |     |   \r\nLEFT-WALL furthermore , instead of manually optimizing.v the code.n for.p \r\n\r\n\r\n----------------------Xp--------------------------------------------------\r\n-------------------------------------------------+                        \r\n-------------------------------------------------+                        \r\n----CO-------------------------------------------+                        \r\n-------------------------------+                 |                        \r\n----------Js-------------+     |                 |                        \r\n   +----------Ds---------+     |                 |                   +----\r\n   |          +-----A----+     |      +----AN----+---------Sp--------+    \r\n   |          |          |     |      |          |                   |    \r\nevery.d individual.a feature.n , language.n designers.n [instead] write.v \r\n\r\n\r\n----------------------------------------+\r\n                                        |\r\n                                        |\r\n                                        |\r\n                                        |\r\n                                        |\r\n------------Op----------------+         |\r\n    +-----A----+------AN------+         |\r\n    |          |              |         |\r\ngeneric.a compiler.n optimizations[!].n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "We show that the attribute grammar formalism supports specification of layout languages. It is unclear how to encode complicated layout language features with the traditional formalism, so we support a rich form of attribute grammars and reduce reasoning about them to handling a more traditional formalism (reducer in Figure~\\ref{fig:architecture}). The remainder of this chapter introduces the high-level attribute grammar formalism, how to specify layout languages using it, and an intuition for the reduction into a lower-level formalism.", "errors": [], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "              \n}  \n                                                                  \n               \n}\n\\caption{For a language of horizontal boxes: (a) input tree to solve and (b) attribute grammar specifying the layout language. Specification language of attribute grammars shown in (c).%and (c) dynamic data dependencies.\n}\n                \n            ", "errors": [{"i": [[104, 5, 9, 113, "For"], [104, 5, 13, 117, "a"], [104, 5, 15, 119, "language"], [104, 5, 24, 128, "of"], [104, 5, 27, 131, "horizontal"], [104, 5, 38, 142, "boxes"], [104, 5, 45, 149, "(a)"], [104, 5, 49, 153, "input"], [104, 5, 55, 159, "tree"], [104, 5, 60, 164, "to"], [104, 5, 63, 167, "solve"], [104, 5, 69, 173, "and"], [104, 5, 73, 177, "(b)"], [104, 5, 77, 181, "attribute"], [104, 5, 87, 191, "grammar"], [104, 5, 95, 199, "specifying"], [104, 5, 106, 210, "the"], [104, 5, 110, 214, "layout"], [104, 5, 117, 221, "language"]], "s": " For a language of horizontal boxes: (a) input tree to solve and (b)  \battribute grammar specifying the layout language.\r\nNo complete linkages found.\r\nFound 4 linkages (4 had no P.P. violations) at null count 3\r\n\tLinkage 1, cost vector = (UNUSED=3 DIS=4 AND=0 LEN=83)\r\n\r\n    +--------------------------------------------------------------------\r\n    +-----------------------------------------------------Wi-------------\r\n    |       +-------------------------------------------------CO---------\r\n    |       |                                   +------------MXp---------\r\n    |       |                                   |        +--------Xd-----\r\n    |       +----Jp----+      +--------Jp-------+        | +-------Ds----\r\n    |       |   +--Dsu-+--Mp--+       +----A----+        | |        +---A\r\n    |       |   |      |      |       |         |        | |        |    \r\nLEFT-WALL for.p a language.n of horizontal.a boxes.n [:] ( a [)] input.n \r\n\r\n\r\n------------Xp-----------------------------------------------------------\r\n---------------------------------------+                                 \r\n---------------------------------------+                                 \r\n---+                                   |                                 \r\n---+-------------Xc-------------+      |                      +----------\r\n---+-----Bs----+                |      |                      |       +--\r\nN--+--R--+--I--+                |      +----Os----+-----Mg----+       |  \r\n   |     |     |                |      |          |           |       |  \r\ntree.n to.r solve.v and [(] b.v ) attribute.v grammar.n specifying.v the \r\n\r\n\r\n--------------------+\r\n                    |\r\n                    |\r\n                    |\r\n-Os-----------+     |\r\n-----D*u------+     |\r\n    +----AN---+     |\r\n    |         |     |\r\nlayout.n language.n . \r\n\r\n\r\n    +--------------------------------------------------------------------\r\n    +-----------------------------------------------------Wi-------------\r\n    |       +-------------------------------------------------CO---------\r\n    |       |                                   +------------MXp---------\r\n    |       |                                   |        +--------Xd-----\r\n    |       +----Jp----+      +--------Jp-------+        | +-------Ds----\r\n    |       |   +--Dsu-+--Mp--+       +----A----+        | |        +---A\r\n    |       |   |      |      |       |         |        | |        |    \r\nLEFT-WALL for.p a language.n of horizontal.a boxes.n [:] ( a [)] input.n \r\n\r\n\r\n------------Xp-----------------------------------------------------------\r\n---------------------------------------+                                 \r\n---------------------------------------+                                 \r\n---+                                   |                                 \r\n---+-------------Xc-------------+      |                      +----------\r\n---+------------Bs-----------+  |      |                      |       +--\r\nN--+--R--+---------I---------+  |      +----Os----+-----Mg----+       |  \r\n   |     |                   |  |      |          |           |       |  \r\ntree.n to.r solve.v and [(] b.v ) attribute.v grammar.n specifying.v the \r\n\r\n\r\n--------------------+\r\n                    |\r\n                    |\r\n                    |\r\n-Os-----------+     |\r\n-----D*u------+     |\r\n    +----AN---+     |\r\n    |         |     |\r\nlayout.n language.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[104, 5, 127, 231, "Specification"], [104, 5, 141, 245, "language"], [104, 5, 150, 254, "of"], [104, 5, 153, 257, "attribute"], [104, 5, 163, 267, "grammars"], [104, 5, 172, 276, "shown"], [104, 5, 178, 282, "in"], [104, 5, 181, 285, "(c)"]], "s": " Specification language of attribute grammars shown in (c).\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 6\r\n\tUnique linkage, cost vector = (UNUSED=6 DIS=0 AND=0 LEN=13)\r\n\r\n    +-----------------------------------------Xp----------------------------\r\n    +--------------------Wi--------------------+-----Op----+---Mv---+--K--+ \r\n    |                                          |           |        |     | \r\nLEFT-WALL [specification] [language] [of] attribute.v grammars.n shown.v in \r\n\r\n\r\n------------+\r\n            |\r\n            |\r\n[(] [c] [)] . \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\section{Background: Layout with Classical Attribute Grammar}", "errors": [{"i": [[115, 0, 9, 9, "Background"], [115, 0, 21, 21, "Layout"], [115, 0, 28, 28, "with"], [115, 0, 33, 33, "Classical"], [115, 0, 43, 43, "Attribute"], [115, 0, 53, 53, "Grammar"]], "s": " Background: Layout with Classical Attribute Grammar.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 9\r\n\tUnique linkage, cost vector = (UNUSED=10 DIS=0 AND=0 LEN=0)\r\n\r\n[Background] [:] [Layout] [with] [Classical] [Attribute] [Grammar] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "This section describes specifying a simple layout language as an attribute grammar and two classical implementation strategies. We reuse the example throughout our work to explore various concepts.", "errors": [{"i": [[117, 0, 0, 0, "This"], [117, 0, 5, 5, "section"], [117, 0, 13, 13, "describes"], [117, 0, 23, 23, "specifying"], [117, 0, 34, 34, "a"], [117, 0, 36, 36, "simple"], [117, 0, 43, 43, "layout"], [117, 0, 50, 50, "language"], [117, 0, 59, 59, "as"], [117, 0, 62, 62, "an"], [117, 0, 65, 65, "attribute"], [117, 0, 75, 75, "grammar"], [117, 0, 83, 83, "and"], [117, 0, 87, 87, "two"], [117, 0, 91, 91, "classical"], [117, 0, 101, 101, "implementation"], [117, 0, 116, 116, "strategies"]], "s": " This section describes specifying a simple layout language as an att \bribute grammar and two classical implementation strategies.\r\nNo complete linkages found.\r\nFound 40 linkages (30 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=1 AND=1 LEN=38)\r\n\r\n    +-------------------------------------------------------------------\r\n    |                           +-------------------------MVp-----------\r\n    |                           +---------------------Os----------------\r\n    +-------Wd-------+          |                   +-----------Dsu-----\r\n    |        +--Dsu--+----Ss----+                   |     +----A---+----\r\n    |        |       |          |                   |     |        |    \r\nLEFT-WALL this.d section.n describes.v [specifying] a simple.a layout.n \r\n\r\n\r\n-----------Xp-----------------------------------------------------------------\r\n-------------+                                                                \r\n-----+       +----------Jp---------+                                          \r\n-----+       |   +-------Dsu-------+                                          \r\nAN---+       |   |      +----AN----+                                          \r\n     |       |   |      |          |                                          \r\nlanguage.n as.p an attribute.n grammar.n and two classical.a implementation.n \r\n\r\n\r\n-------------+\r\n             |\r\n             |\r\n             |\r\n             |\r\n             |\r\nstrategies.n . \r\n\r\n\r\n    +-------------------------------------------------------------------\r\n    |                           +-------------------------MVp-----------\r\n    |                           +---------------------Os----------------\r\n    +-------Wd-------+          |                   +-----------Dsu-----\r\n    |        +--Dsu--+----Ss----+                   |     +----A---+----\r\n    |        |       |          |                   |     |        |    \r\nLEFT-WALL this.d section.n describes.v [specifying] a simple.a layout.n \r\n\r\n\r\n-----------Xp-----------------------------------------------------------------\r\n-------------+                                                                \r\n-----+       +----------------------------------Jp----------------------------\r\n-----+       |                                +-----------------Dmc-----------\r\nAN---+       |                                |       +-------A------+------AN\r\n     |       |                                |       |              |        \r\nlanguage.n as.p an attribute.n grammar.n and two classical.a implementation.n \r\n\r\n\r\n-------------+\r\n             |\r\n------+      |\r\n------+      |\r\n------+      |\r\n      |      |\r\nstrategies.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsection{Attribute Grammars}", "errors": [], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Consider solving the tree of horizontal boxes shown in Figure~                                . As input, a webpage author provides a tree with constraints (Figure~                                    ). Only some node attribute values are provided: in this case, only the widths and heights of leaf nodes. The meaning of a horizontal layout is that, as is visualized, the boxes will be placed side-by-side. The layout engine must solve for all remaining x, y, width, and height attributes. ", "errors": [{"i": [123, 0, 393, 393, "side-by-side"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "We declaratively specify the layout language of horizontal boxes,         ,  as shown in Figure~                                  , with an attribute grammar~                                 . First, the specification defines the set of well-formed input trees as the derivations of a context-free grammar. We use the standard notation~[[CITE]]. In this case, a document is an unbalanced binary tree of arbitrary depth where the root node has label            and intermediate nodes have label              . Second, the specification defines semantic functions that relate attributes associated with each node. For example, the width of an intermediate horizontal node is the sum of its children widths. Likewise, the width of a leaf node is provided by the user, which is encoded by the nullary function call $input_w()$:", "errors": [{"i": [125, 0, 789, 789, "nullary"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "The specification intentionally does not define the evaluation order. For example, the specification does not state whether to compute a node's width before its height. Likewise, our optimized approach will compute the attributes as a sequence of tree traversals, but the specification does not state what those traversals are. Leaving the evaluation order unspecified provides freedom for our compilers to pick an efficient parallel order. Irrespective of whatever evaluation order is ultimately used to solve for the attribute values, the statements define constraints that must hold over the computed result. Attribute grammars can therefore be thought of as a single assignment language where attributes are dataflow variables~[[CITE]].", "errors": [{"i": [[136, 0, 612, 612, "Attribute"], [136, 0, 622, 622, "grammars"], [136, 0, 631, 631, "can"], [136, 0, 635, 635, "therefore"], [136, 0, 645, 645, "be"], [136, 0, 648, 648, "thought"], [136, 0, 656, 656, "of"], [136, 0, 659, 659, "as"], [136, 0, 662, 662, "a"], [136, 0, 664, 664, "single"], [136, 0, 671, 671, "assignment"], [136, 0, 682, 682, "language"], [136, 0, 691, 691, "where"], [136, 0, 697, 697, "attributes"], [136, 0, 708, 708, "are"], [136, 0, 712, 712, "dataflow"], [136, 0, 721, 721, "variables"], [136, 0, 733, 733, "CITE"]], "s": " Attribute grammars can therefore be thought of as a single assignmen \bt language where attributes are dataflow variables~[[CITE].\r\nNo complete linkages found.\r\nFound 640 linkages (120 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=0 AND=0 LEN=31)\r\n\r\n    +-----------------------------------------------------------------\r\n    |                                                        +--------\r\n    |                                                        |   +----\r\n    +---------Wd---------+       +-------Ix------+-----Pv----+   |  +-\r\n    |         +----AN----+---Sp--+       +---E---+     +-IDYN+MVp+  | \r\n    |         |          |       |       |       |     |     |   |  | \r\nLEFT-WALL Attribute grammars.n can.v therefore be.v thought of as.p a \r\n\r\n\r\n----------------Xp------------------------------------------------------\r\n------------MVp--------------------+                                    \r\n-----------Jp--------------+       |                                    \r\n------------Dsu------------+       |                                    \r\n    +-----A----+-----AN----+       +----Cs---+---Spx--+---I*v---+-------\r\n    |          |           |       |         |        |         |       \r\nsingle.a assignment.n language.n where attributes.n are.v dataflow[?].v \r\n\r\n\r\n--------------------------+\r\n                          |\r\n                          |\r\n                          |\r\n-Os-------+               |\r\n          |               |\r\nvariables~[[CITE[?].n []] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "The language of attribute grammars is defined in Figure~                        . In addition the defining the context free grammar, it supports single-assignment constraints over attributes of nodes in a production. Our example uses the following encoding. Semantic functions are pure and left uninterpreted, so, for example, we encode the addition of widths as ``                                             ''. Our program analysis techniques do not need to know the contents of the function, just that the output of a call depends purely on the inputs.  For the same reason, we encode constant values as nullary function calls. ", "errors": [{"i": [139, 0, 608, 608, "nullary"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "To specify grammars more complicated than         , we describe linguistic extensions for richer functional specifications (Section~\\ref{sec:desugaring}) and, to control the evaluation order, behavioral specification (Chapters~\\ref{chap:3} and \\ref{chap:4}).", "errors": [{"i": [141, 0, 137, 137, "sec"], "s": ["Dec", "sea", "sect", "see", "set", "sew", "sex", "sic", "spec"], "e": "spell"}, {"i": [141, 0, 141, 141, "desugaring"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "              \n                                                      \n                                           \n\\includegraphics[trim=0 0 0 0,clip,width=1.0\\columnwidth]{chapter2/deps}\n              }\n                                                                 \n                                           \n\\includegraphics[trim=0 0 0 0,clip,width=1.0\\columnwidth]{chapter2/depsstep}\n              }\n\\caption{\\textbf{Dynamic data dependencies and evaluation}. Shown for constraint tree  in Figure~ZZZ~(a). Circles denote attributes, with black circles denote attributes with resolved dependencies such as \\sched{input()}s. Thin lines show data dependencies and thick lines show production derivations. Second chart shows the dependency graph resulting from evaluating all source nodes and marking them as resolved.}\n                \n            ", "errors": [{"i": [143, 9, 97, 503, "ZZZ"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsection{Dynamic data dependencies and dynamic evaluation}\nA simple and classic evaluation strategy is to \\emph{dynamically} compute over a tree. The evaluator dynamically follows the dynamic data dependencies between instances of attributes. The dynamic evaluation strategy is too slow for our use cases, but it introduces the key concepts of dynamic data dependencies, the dynamic semantics of attributes grammars, and the corresponding dynamic interpreter.", "errors": [{"i": [[157, 0, 12, 12, "Dynamic"], [157, 0, 20, 20, "data"], [157, 0, 25, 25, "dependencies"], [157, 0, 38, 38, "and"], [157, 0, 42, 42, "dynamic"], [157, 0, 50, 50, "evaluation"]], "s": " Dynamic data dependencies and dynamic evaluation.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 8\r\n\tUnique linkage, cost vector = (UNUSED=9 DIS=0 AND=0 LEN=0)\r\n\r\n[Dynamic] [data] [dependencies] [and] [dynamic] [evaluation] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "An instance of a document corresponds to the dependency graph shown in Figure~                               . Each attribute of a tree node is either a source, meaning its value can be computed based on other known values, or it cannot be evaluated until other attribute values are known. It is a dynamic dependency graph in that each data dependency in the static code may be instantiated as multiple data dependencies given a tree at runtime. ", "errors": [], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "The dynamic data dependency graph leads to a simple semantics for the result of evaluation. The graph corresponds to a system of equations where edges link instance variables. For example, static code                                             instantiates twice for the Figure~                               : once for each $x$ attribute with an incoming elbow connector. The value of both $x$s are constrained by distinct instances of the above constraint. If the dependency graph is a directed acyclic graph and each attribute appears on the lefthand side of exactly one equality statement (\\emph{dataflow variables}), there is exactly one solution to the system of equations.", "errors": [{"i": [162, 0, 546, 546, "lefthand"], "s": ["left hand", "left-hand"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "A simple procedure solves an instance of a system of equations: topological traversal. The algorithm is as follows:\n              \n                                                                                                                                                                                                                                                                                                                                                                                                                                                ", "errors": [{"i": [[164, 0, 0, 0, "A"], [164, 0, 2, 2, "simple"], [164, 0, 9, 9, "procedure"], [164, 0, 19, 19, "solves"], [164, 0, 26, 26, "an"], [164, 0, 29, 29, "instance"], [164, 0, 38, 38, "of"], [164, 0, 41, 41, "a"], [164, 0, 43, 43, "system"], [164, 0, 50, 50, "of"], [164, 0, 53, 53, "equations"], [164, 0, 64, 64, "topological"], [164, 0, 76, 76, "traversal"]], "s": " A simple procedure solves an instance of a system of equations: topo \blogical traversal.\r\nNo complete linkages found.\r\nFound 77 linkages (2 had no P.P. violations) at null count 3\r\n\tLinkage 1, cost vector = (UNUSED=3 DIS=2 AND=0 LEN=19)\r\n\r\n    +------------------------------------------------------Xp------------\r\n    +----------Wd---------+                                              \r\n    |     +------Dsu------+          +-----Os-----+      +---Js--+       \r\n    |     |     +----A----+----Ss----+     +--Ds--+--Mp--+ +--Ds-+--Mp-+-\r\n    |     |     |         |          |     |      |      | |     |     | \r\nLEFT-WALL a simple.a procedure.n solves.v an instance.n of a system.n of \r\n\r\n\r\n------------------------------------------+\r\n                                          |\r\n                                          |\r\n-Jp--+                                    |\r\n     |                                    |\r\nequations.n [:] [topological] [traversal] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[164, 0, 87, 87, "The"], [164, 0, 91, 91, "algorithm"], [164, 0, 101, 101, "is"], [164, 0, 104, 104, "as"], [164, 0, 107, 107, "follows"]], "s": " The algorithm is as follows:.\r\nNo complete linkages found.\r\nFound 2 linkages (2 had no P.P. violations) at null count 3\r\n\tLinkage 1, cost vector = (UNUSED=3 DIS=1 AND=0 LEN=9)\r\n\r\n    +----------------------Xp---------------------+\r\n    +------Wd------+                              |\r\n    |      +---Ds--+---------Ss---------+         |\r\n    |      |       |                    |         |\r\nLEFT-WALL the algorithm.n [is] [as] follows.v [:] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\caption{\\textbf{Dynamic attribute grammar evaluator.} It selects attributes in a safe order by dynamically removing dependency edges as they are resolved. }\n                   \n            \nThe algorithm literately finds an attribute whose dependencies have all been previously resolved, evaluates the attribute, and repeats. If the input graph is a directed acyclic graph, this procedure is guaranteed to terminate. The insight is that a directed acyclic graph has at least one fringe node, the loop removes them, and removing these nodes yields a smaller directed acylic graph.", "errors": [{"i": [179, 3, 376, 567, "acylic"], "s": ["acrylic", "acyclic"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "The dynamic evaluation strategy provides a small explanation for the natural semantics, but it leaves several challenges. First, runtime manipulation of a dynamic dependency graph introduces high overheads because every dynamic dependency edge must be manipulated. Second, it is unsafe. For example, a cycle in the dependency graph causes the above evaluation strategy to get stuck, so dynamic evaluators must introduce runtime cycle check. Designers can build layout widgets that, depending on how they are invoked, fail to display!", "errors": [{"i": [[184, 0, 441, 441, "Designers"], [184, 0, 451, 451, "can"], [184, 0, 455, 455, "build"], [184, 0, 461, 461, "layout"], [184, 0, 468, 468, "widgets"], [184, 0, 476, 476, "that"], [184, 0, 482, 482, "depending"], [184, 0, 492, 492, "on"], [184, 0, 495, 495, "how"], [184, 0, 499, 499, "they"], [184, 0, 504, 504, "are"], [184, 0, 508, 508, "invoked"], [184, 0, 517, 517, "fail"], [184, 0, 522, 522, "to"], [184, 0, 525, 525, "display"]], "s": " Designers can build layout widgets that, depending on how they are i \bnvoked, fail to display!.\r\nNo complete linkages found.\r\nFound 200 linkages (200 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=1 AND=0 LEN=43)\r\n\r\n    +----------------------------------------------------------------X\r\n    |                                            +--------------------\r\n    |                                            |           +--------\r\n    |                        +---------Op--------+           +--------\r\n    +----Wd---+---S---+---I--+        +----AN----+-----R-----+      +-\r\n    |         |       |      |        |          |           |      | \r\nLEFT-WALL Designers can.v build.v layout.n widgets[!].n that.misc-r , \r\n\r\n\r\np---------------------------------------------------------------+   \r\n------------Bp-------------------------------+                  |   \r\n------------------RS-------------------------+                  |   \r\n-MVx---------+------------Xc------------+    |                  |   \r\n-----Xd------+QI+-Cs-+-Spx+---Pv--+     |    +-MVp-+--Jp--+     |   \r\n             |  |    |    |       |     |    |     |      |     |   \r\n[depending] on how they are.v invoked.v , fail.v to.r display.n ! [.] \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\section{Desugaring Loops and Other Modern Constructs}\n                      ", "errors": [{"i": [191, 0, 9, 9, "Desugaring"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "The attribute grammar formalism was invented for describing semantics~[[CITE]] and before many modern constructs became mainstream: we had to design extensions for improved expressiveness and maintainability. Our extensions exploit concepts from structured, object-oriented, and functional programming. Other language designers have build such extensions as well~[[CITE]]: our challenge was to make expressive extensions that facilitate effective parallelization and do not overly complicate language and tool implementation. This section documents the language features and how they simplify implementation, and leaves performance optimization to the next chapter.", "errors": [{"i": [[194, 0, 526, 526, "This"], [194, 0, 531, 531, "section"], [194, 0, 539, 539, "documents"], [194, 0, 549, 549, "the"], [194, 0, 553, 553, "language"], [194, 0, 562, 562, "features"], [194, 0, 571, 571, "and"], [194, 0, 575, 575, "how"], [194, 0, 579, 579, "they"], [194, 0, 584, 584, "simplify"], [194, 0, 593, 593, "implementation"], [194, 0, 609, 609, "and"], [194, 0, 613, 613, "leaves"], [194, 0, 620, 620, "performance"], [194, 0, 632, 632, "optimization"], [194, 0, 645, 645, "to"], [194, 0, 648, 648, "the"], [194, 0, 652, 652, "next"], [194, 0, 657, 657, "chapter"]], "s": " This section documents the language features and how they simplify i \bmplementation, and leaves performance optimization to the next chapter.\r\nNo complete linkages found.\r\nFound 113 linkages (52 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=2 AND=3 LEN=53)\r\n\r\n    +----------------------------------------------------------------------\r\n    |                           +------------Ce------------+               \r\n    +-------Wd-------+          |       +--------Dmc-------+               \r\n    |        +--Dsu--+----Ss----+       |       +----AN----+------------Sp-\r\n    |        |       |          |       |       |          |               \r\nLEFT-WALL this.d section.n documents.v the language.n features.n and [how] \r\n\r\n\r\n-----------------Xp-------------------------------------------\r\n----------+------Os-----+                                     \r\n          |             |                                     \r\nthey simplify.v implementation.n , and leaves.v performance.n \r\n\r\n\r\n--------------------------------------------+\r\n                                            |\r\n                                            |\r\n                                            |\r\n                                            |\r\noptimization[!].n to.r the next.a chapter.n . \r\n\r\n\r\n    +----------------------------------------------------------------------\r\n    +-------Wd-------+                                                     \r\n    |        +--Dsu--+----Ss----+---------------------Ce-------------------\r\n    |        |       |          |                                          \r\nLEFT-WALL this.d section.n documents.v the language.n features.n and [how] \r\n\r\n\r\n-----------------Xp-------------------------------------------\r\n--+---Sp--+------Os-----+                                     \r\n  |       |             |                                     \r\nthey simplify.v implementation.n , and leaves.v performance.n \r\n\r\n\r\n--------------------------------------------+\r\n                                            |\r\n                                            |\r\n                                            |\r\noptimization[!].n to.r the next.a chapter.n . \r\n\r\n\r\n    +----------------------------------------------------------------------\r\n    |                                                                      \r\n    +-------Wd-------+                                                     \r\n    |        +--Dsu--+-----------------------------------------------Ss----\r\n    |        |       |                                                     \r\nLEFT-WALL this.d section.n documents.v the language.n features.n and [how] \r\n\r\n\r\n-----------------Xp-------------------------------------------\r\n                                           +------------------\r\n                                           +------------Os----\r\n-------------------------------------------+          +-------\r\n                                           |          |       \r\nthey simplify.v implementation.n , and leaves.v performance.n \r\n\r\n\r\n--------------------------------------------+\r\nMVp-----------------+--------Js-------+     |\r\n--------+           |   +------Ds-----+     |\r\nAN------+           |   +--L--+       |     |\r\n        |           |   |     |       |     |\r\noptimization[!].n to.r the next.a chapter.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Our key insight is that pre- and post-processing supports desugaring a feature-rich attribute grammar into the canonical attribute grammar notation. Tools then operate at the most appropriate stage, such as our scheduler on the small, canonical attribute grammar representation. Likewise, our code generators take a generated schedule and relate it back to a representation from early in the preprocessing stage. Many of the below features are built as explicit compiler stages, but over time, we found that declarative tree rewriting systems such as ANTLR and OMeta support automating individual stages.", "errors": [{"i": [196, 0, 24, 24, "pre-"], "s": ["are", "ere", "ire", "ore", "pare", "per", "pie", "Poe", "pore", "prep", "prey", "pro", "pry", "pure", "pyre", "re"], "e": "spell"}, {"i": [196, 0, 58, 58, "desugaring"], "s": [], "e": "spell"}, {"i": [196, 0, 551, 551, "ANTLR"], "s": ["ANTLER"], "e": "spell"}, {"i": [196, 0, 561, 561, "OMeta"], "s": ["Meta", "Omega"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "              \n}\n\\caption{\\textbf{Interfaces for tree grammars}. Subfigures show manually encoding multiple production right-hand sides, an encoding that uses a            non-terminal for indirection, and the high-level encoding using interfaces and classes.}\n                 \n            ", "errors": [{"i": [272, 2, 48, 65, "Subfigures"], "s": ["Sub figures", "Sub-figures"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\caption{\\textbf{Input tree as graph with labeled nodes and edges}. Specified in the JSON notation.}\n                    \n            ", "errors": [{"i": [[291, 0, 17, 17, "Input"], [291, 0, 23, 23, "tree"], [291, 0, 28, 28, "as"], [291, 0, 31, 31, "graph"], [291, 0, 37, 37, "with"], [291, 0, 42, 42, "labeled"], [291, 0, 50, 50, "nodes"], [291, 0, 56, 56, "and"], [291, 0, 60, 60, "edges"]], "s": " Input tree as graph with labeled nodes and edges.\r\nNo complete linkages found.\r\nFound 2 linkages (2 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=2 AND=3 LEN=18)\r\n\r\n    +----------------------------------Xp----------------------------------+\r\n    |        +---------------------Op---------------------+                |\r\n    |        |                   +-----------AN-----------+                |\r\n    +---Wi---+       +-----AN----+               +----A---+                |\r\n    |        |       |           |               |        |                |\r\nLEFT-WALL input.v tree.n [as] graph.n [with] labeled.v nodes.n and edges.n . \r\n\r\n\r\n    +----------------------------------Xp----------------------------------+\r\n    +---Wi---+---------------------------Op---------------------------+    |\r\n    |        |                                                        |    |\r\nLEFT-WALL input.v tree.n [as] graph.n [with] labeled.v nodes.n and edges.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[291, 0, 68, 68, "Specified"], [291, 0, 78, 78, "in"], [291, 0, 81, 81, "the"], [291, 0, 85, 85, "JSON"], [291, 0, 90, 90, "notation"]], "s": " Specified in the JSON notation.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 7\r\n\tUnique linkage, cost vector = (UNUSED=8 DIS=0 AND=0 LEN=0)\r\n\r\n[specified] [in] [the] [JSON] [notation] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsection{Interfaces for Encoding Tree Grammars}\nAttribute grammars are an extension to the tree grammar formalism for defining input trees, so improving the abstraction capabilities of tree grammars also aids the ability to structure attribute grammars. In particular, we found the need to support  abstracting over similar types of non-terminals. Our solution is to provide a notion of classes and interfaces. Our core extension is macro-expressible with attribute grammars and therefore reduces implementation requirements, though it is still important enough that it merits deeper compiler support. ", "errors": [{"i": [[295, 0, 12, 12, "Interfaces"], [295, 0, 23, 23, "for"], [295, 0, 27, 27, "Encoding"], [295, 0, 36, 36, "Tree"], [295, 0, 41, 41, "Grammars"]], "s": " Interfaces for Encoding Tree Grammars.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 7\r\n\tUnique linkage, cost vector = (UNUSED=8 DIS=0 AND=0 LEN=0)\r\n\r\n[Interfaces] [for] [Encoding] [Tree] [Grammars] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Consider the code duplication performed when extending        with vertical boxes. The children of a             could be a horizontal box or a vertical box, and the same for the children of a vertical box. Figure~\\ref{fig:face:problem} shows that the 3 productions of        grew to be 11. The example highlights that canonical attribute grammars cannot abstract over node types. Adding a new box type requires modifying all previous box classes, and in the presence multiple children, extension suffers exponential costs. ", "errors": [{"i": [[299, 0, 83, 83, "The"], [299, 0, 87, 87, "children"], [299, 0, 96, 96, "of"], [299, 0, 99, 99, "a"], [299, 0, 113, 113, "could"], [299, 0, 119, 119, "be"], [299, 0, 122, 122, "a"], [299, 0, 124, 124, "horizontal"], [299, 0, 135, 135, "box"], [299, 0, 139, 139, "or"], [299, 0, 142, 142, "a"], [299, 0, 144, 144, "vertical"], [299, 0, 153, 153, "box"], [299, 0, 158, 158, "and"], [299, 0, 162, 162, "the"], [299, 0, 166, 166, "same"], [299, 0, 171, 171, "for"], [299, 0, 175, 175, "the"], [299, 0, 179, 179, "children"], [299, 0, 188, 188, "of"], [299, 0, 191, 191, "a"], [299, 0, 193, 193, "vertical"], [299, 0, 202, 202, "box"]], "s": " The children of a             could be a horizontal box or a vertica \bl box, and the same for the children of a vertical box.\r\nNo complete linkages found.\r\nFound 140 linkages (140 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=3 AND=4 LEN=53)\r\n\r\n    +--------------------------------------------------------------------\r\n    |                                       +----------------------------\r\n    |                                       +--------Ost--------+        \r\n    +------Wd------+                        |  +-------Ds-------+        \r\n    |      +--Dmc--+--------Sp-------+--Ix--+  |       +----A---+        \r\n    |      |       |                 |      |  |       |        |        \r\nLEFT-WALL the children.n [of] [a] could.v be.v a horizontal.a box.n or a \r\n\r\n\r\n---Xp----------------------------------------------------------------------+\r\n--MVp-----------------------------+                                        |\r\n                                  |                   +-------Js-------+   |\r\n                                  +-----Jp-----+      | +------Ds------+   |\r\n                                  |    +--Dmc--+--Mp--+ |      +---AN--+   |\r\n                                  |    |       |      | |      |       |   |\r\nvertical.a box.n , and the same for.p the children.n of a vertical.n box.n . \r\n\r\n\r\n    +--------------------------------------------------------------------\r\n    |                                       +----------------------------\r\n    |                                       +-------------------Ost------\r\n    +------Wd------+                        |                          +-\r\n    |      +--Dmc--+--------Sp-------+--Ix--+                          | \r\n    |      |       |                 |      |                          | \r\nLEFT-WALL the children.n [of] [a] could.v be.v a horizontal.a box.n or a \r\n\r\n\r\n---Xp----------------------------------------------------------------------+\r\n--MVp-----------------------------+                                        |\r\n-------------+                    |                   +-------Js-------+   |\r\n-----Ds------+                    +-----Jp-----+      | +------Ds------+   |\r\n     +---A---+                    |    +--Dmc--+--Mp--+ |      +---AN--+   |\r\n     |       |                    |    |       |      | |      |       |   |\r\nvertical.a box.n , and the same for.p the children.n of a vertical.n box.n . \r\n\r\n\r\n    +--------------------------------------------------------------------\r\n    |                                       +----------------------------\r\n    +------Wd------+                        +---------------------------O\r\n    |      +--Dmc--+--------Sp-------+--Ix--+                            \r\n    |      |       |                 |      |                            \r\nLEFT-WALL the children.n [of] [a] could.v be.v a horizontal.a box.n or a \r\n\r\n\r\n---Xp----------------------------------------------------------------------+\r\n--MVp-----------------------------+                   +-------Js-------+   |\r\nyt---------------------------+    +-----Jp-----+      | +------Ds------+   |\r\n                        +IDBR+    |    +--Dmc--+--Mp--+ |      +---AN--+   |\r\n                        |    |    |    |       |      | |      |       |   |\r\nvertical.a box.n , and the same for.p the children.n of a vertical.n box.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[299, 0, 207, 207, "Figure"], [299, 0, 219, 219, "fig"], [299, 0, 223, 223, "face"], [299, 0, 228, 228, "problem"], [299, 0, 237, 237, "shows"], [299, 0, 243, 243, "that"], [299, 0, 248, 248, "the"], [299, 0, 252, 252, "3"], [299, 0, 254, 254, "productions"], [299, 0, 266, 266, "of"], [299, 0, 276, 276, "grew"], [299, 0, 281, 281, "to"], [299, 0, 284, 284, "be"], [299, 0, 287, 287, "11."], [299, 0, 291, 291, "The"], [299, 0, 295, 295, "example"], [299, 0, 303, 303, "highlights"], [299, 0, 314, 314, "that"], [299, 0, 319, 319, "canonical"], [299, 0, 329, 329, "attribute"], [299, 0, 339, 339, "grammars"], [299, 0, 348, 348, "cannot"], [299, 0, 355, 355, "abstract"], [299, 0, 364, 364, "over"], [299, 0, 369, 369, "node"], [299, 0, 374, 374, "types"]], "s": " Figure~\\ref{fig:face:problem shows that the 3 productions of         \bgrew to be 11 The example highlights that canonical attribute grammars cannot ab \bstract over node types.\r\nNo complete linkages found.\r\nFound 3544 linkages (837 of 1000 random linkages had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=1 AND=0 LEN=40)\r\n\r\n    +------------------------------------------------------------\r\n    |                                                            \r\n    |                                                            \r\n    |                                               +--------Cet-\r\n    +---------Wd--------+--------Ss-------+----TH---+       +DD+-\r\n    |                   |                 |         |       |  | \r\nLEFT-WALL Figure~\\ref{fig:face:problem shows.v that.misc-c the 3 \r\n\r\n\r\n---------------------------------------------Xp-------------------------------\r\n                                                           +------------------\r\n                                 +-----------Opt-----------+           +------\r\n------+                          |   +---------Dmcn--------+           |      \r\n-Dmcn-+-------Sp------+-MVi-+-Ix-+   |  +--AN--+-----AN----+-----R-----+      \r\n      |               |     |    |   |  |      |           |           |      \r\nproductions.n [of] grew.v to.r be.v 11 The example.n highlights.n that.misc-r \r\n\r\n\r\n-------------------------------------------------------------------------+\r\n--------------Bp-------------------------------+                         |\r\n-----------Cr----------------+                 |                         |\r\n     +-----------A-----------+                 |       +-----Jp-----+    |\r\n     |           +-----AN----+---Sp---+----I---+--MVp--+     +--AN--+    |\r\n     |           |           |        |        |       |     |      |    |\r\ncanonical.a attribute.n grammars.n cannot abstract.v over node.n types.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "To abstract over node types, we introduce the notion of classes and interfaces (Figure~\\ref{fig:iface:clean}). Classes are similar to the productions of an attribute grammar: the class name specifies the production's lefthand side non-terminal and the children block specifies the production's righthand side. Unlike attribute grammars, an interface name is used for the righthand side rather than the class name.             and             implement interface            , so any class specified to have a             child can have a             or             child within the concrete tree. ", "errors": [{"i": [301, 0, 96, 96, "iface"], "s": ["face", "if ace", "if-ace"], "e": "spell"}, {"i": [301, 0, 217, 217, "lefthand"], "s": ["left hand", "left-hand"], "e": "spell"}, {"i": [301, 0, 294, 294, "righthand"], "s": ["right hand", "right-hand"], "e": "spell"}, {"i": [301, 0, 371, 371, "righthand"], "s": ["right hand", "right-hand"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Classes and interfaces are formally equivalent to tree grammars in the sense of a 1-to-1 correspondence between trees described by both. First, a tree grammar can be expressed with classes and interfaces by treating all productions with the same lefthand-side non-terminal as different classes belonging to the same interface. In the other direction, each interface can be expressed as a production that derives the classes, and the classes expand into productions. Figures~\\ref{fig:iface:clean} and \\ref{fig:iface:rewrite} demonstrate the correspondence for       . The induced implementation requirements are therefore slight in the sense that the construct is sugar for a pattern in the canonical attribute grammars. ", "errors": [{"i": [304, 0, 246, 246, "lefthand-side"], "s": [], "e": "spell"}, {"i": [304, 0, 483, 483, "iface"], "s": ["face", "if ace", "if-ace"], "e": "spell"}, {"i": [304, 0, 509, 509, "iface"], "s": ["face", "if ace", "if-ace"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "We depart from the correspondence for the encoding of trees in two ways. First, we represent input as a tree with labeled nodes and edges. Node labels denote the class and edge labels specify child bindings. Figure~\\ref{fig:hboxjson} uses the JSON format common to dynamic languages for an instance of a tree in       . By naming children, such as             and             , we eliminate sensitivity to their order within a code block. With order sensitivity, adding a middle child               would needlessly require refactoring references to the repositioned element             . Likewise, reordering children in the input data does not require refactoring the attribute grammar.", "errors": [{"i": [306, 0, 224, 224, "hboxjson"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Our second departure from the canonical attribute grammar encoding optimizes the data representation by eliding intermediate interface nodes. The reduction to attribute grammars suggests adding a new non-terminal for each interface, but doing so in the data representation doubles the number of nodes in the concrete tree. Making the interface pattern a language construct with compiler support eliminates associated costs, such as cutting file size for runtime parsing of big data visualizations.", "errors": [], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\caption{\\textbf{Input tree as graph with labeled nodes and edges}. Specified in the JSON notation.}\n                    \n            ", "errors": [{"i": [[325, 0, 17, 17, "Input"], [325, 0, 23, 23, "tree"], [325, 0, 28, 28, "as"], [325, 0, 31, 31, "graph"], [325, 0, 37, 37, "with"], [325, 0, 42, 42, "labeled"], [325, 0, 50, 50, "nodes"], [325, 0, 56, 56, "and"], [325, 0, 60, 60, "edges"]], "s": " Input tree as graph with labeled nodes and edges.\r\nNo complete linkages found.\r\nFound 2 linkages (2 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=2 AND=3 LEN=18)\r\n\r\n    +----------------------------------Xp----------------------------------+\r\n    |        +---------------------Op---------------------+                |\r\n    |        |                   +-----------AN-----------+                |\r\n    +---Wi---+       +-----AN----+               +----A---+                |\r\n    |        |       |           |               |        |                |\r\nLEFT-WALL input.v tree.n [as] graph.n [with] labeled.v nodes.n and edges.n . \r\n\r\n\r\n    +----------------------------------Xp----------------------------------+\r\n    +---Wi---+---------------------------Op---------------------------+    |\r\n    |        |                                                        |    |\r\nLEFT-WALL input.v tree.n [as] graph.n [with] labeled.v nodes.n and edges.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[325, 0, 68, 68, "Specified"], [325, 0, 78, 78, "in"], [325, 0, 81, 81, "the"], [325, 0, 85, 85, "JSON"], [325, 0, 90, 90, "notation"]], "s": " Specified in the JSON notation.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 7\r\n\tUnique linkage, cost vector = (UNUSED=8 DIS=0 AND=0 LEN=0)\r\n\r\n[specified] [in] [the] [JSON] [notation] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsection{Interfaces for attributes and information hiding.}\nOur system provides lightweight specification annotations for different types of attributes, and coupled with the interface construct, it supports defining relationships between attributes across different classes.", "errors": [{"i": [[330, 0, 12, 12, "Interfaces"], [330, 0, 23, 23, "for"], [330, 0, 27, 27, "attributes"], [330, 0, 38, 38, "and"], [330, 0, 42, 42, "information"], [330, 0, 54, 54, "hiding"]], "s": " Interfaces for attributes and information hiding.\r\nNo complete linkages found.\r\nFound 2 linkages (2 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=0 AND=0 LEN=8)\r\n\r\n    +-------------------------------Xp-------------------------------+\r\n    +----Wd----+--------Ss-------+--------Os--------+-----Mg----+    |\r\n    |          |                 |                  |           |    |\r\nLEFT-WALL Interfaces [for] attributes.v [and] information.n hiding.v . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Each static attribute is annotated with its assignment type and its embedded value type:\n               \n      \\textbf{Assignment types.}\nThe assignment type denotes whether the input tree defines the value, such as in               , or whether the attribute grammar defines it, as in             . Assignments to an input type are illegal, and multiple assignments to a variable type are also illegal. ", "errors": [{"i": [[333, 0, 0, 0, "Each"], [333, 0, 5, 5, "static"], [333, 0, 12, 12, "attribute"], [333, 0, 22, 22, "is"], [333, 0, 25, 25, "annotated"], [333, 0, 35, 35, "with"], [333, 0, 40, 40, "its"], [333, 0, 44, 44, "assignment"], [333, 0, 55, 55, "type"], [333, 0, 60, 60, "and"], [333, 0, 64, 64, "its"], [333, 0, 68, 68, "embedded"], [333, 0, 77, 77, "value"], [333, 0, 83, 83, "type"]], "s": " Each static attribute is annotated with its assignment type and its  \bembedded value type:.\r\nNo complete linkages found.\r\nFound 2 linkages (2 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=3 AND=1 LEN=27)\r\n\r\n    +---------------------------------------------------------Xp-----------\r\n    +-----------Wd-----------+                         +----------Js-------\r\n    |       +-------Ds-------+                         |   +--------Ds-----\r\n    |       |      +----A----+---Ss---+---Pv--+---MVp--+   |        +----AN\r\n    |       |      |         |        |       |        |   |        |      \r\nLEFT-WALL each static.a attribute.n is.v annotated.v with its assignment.n \r\n\r\n\r\n---------------------------------------------+\r\n---+                                         |\r\n---+                                         |\r\n---+                                         |\r\n   |                                         |\r\ntype.n and its embedded.v value.n type.n [:] . \r\n\r\n\r\n    +---------------------------------------------------------Xp-----------\r\n    +-----------Wd-----------+                         +-------------------\r\n    |       +-------Ds-------+                         |                   \r\n    |       |      +----A----+---Ss---+---Pv--+---MVp--+                   \r\n    |       |      |         |        |       |        |                   \r\nLEFT-WALL each static.a attribute.n is.v annotated.v with its assignment.n \r\n\r\n\r\n---------------------------------------------+\r\n--------Js---------------------------+       |\r\n            +-----------Ds-----------+       |\r\n            |       +----A---+---AN--+       |\r\n            |       |        |       |       |\r\ntype.n and its embedded.v value.n type.n [:] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[333, 3, 0, 138, "The"], [333, 3, 4, 142, "assignment"], [333, 3, 15, 153, "type"], [333, 3, 20, 158, "denotes"], [333, 3, 28, 166, "whether"], [333, 3, 36, 174, "the"], [333, 3, 40, 178, "input"], [333, 3, 46, 184, "tree"], [333, 3, 51, 189, "defines"], [333, 3, 59, 197, "the"], [333, 3, 63, 201, "value"], [333, 3, 70, 208, "such"], [333, 3, 75, 213, "as"], [333, 3, 78, 216, "in"], [333, 3, 97, 235, "or"], [333, 3, 100, 238, "whether"], [333, 3, 108, 246, "the"], [333, 3, 112, 250, "attribute"], [333, 3, 122, 260, "grammar"], [333, 3, 130, 268, "defines"], [333, 3, 138, 276, "it"], [333, 3, 142, 280, "as"], [333, 3, 145, 283, "in"]], "s": " The assignment type denotes whether the input tree defines the value \b, such as in               , or whether the attribute grammar defines it, as in  \b.\r\nNo complete linkages found.\r\nFound 9 linkages (9 had no P.P. violations) at null count 7\r\n\tLinkage 1, cost vector = (UNUSED=7 DIS=3 AND=0 LEN=66)\r\n\r\n    +----------------------------------------------------------------------\r\n    |                                                                      \r\n    +--------------------------------Wd--------------------------------+   \r\n    |      +-----------------------------Ds----------------------------+   \r\n    |      |        +----AN---+---------------AN---------------+---AN--+---\r\n    |      |        |         |                                |       |   \r\nLEFT-WALL the assignment.n type.n [denotes] [whether] [the] input.n tree.n \r\n\r\n\r\n-----------------Xp---------------------------------------------------\r\n                                 +-----------------------------Xc-----\r\n    +-------------MVs------------+-------------------Cs---------------\r\n    +-----Os-----+               |                     +--------D*u---\r\nSs--+      +-D*u-+    +----Xd----+                     |       +----AN\r\n    |      |     |    |          |                     |       |      \r\ndefines.v the value.n , [such] as.p [in] , or whether the attribute.n \r\n\r\n\r\n-----------------------------------+\r\n-----------------------+           |\r\n----+                  |           |\r\n----+                  |           |\r\n----+----Ss---+--Ox--+ |           |\r\n    |         |      | |           |\r\ngrammar.n defines.v it , [as] [in] . \r\n\r\n\r\n    +----------------------------------------------------------------------\r\n    |                                                                      \r\n    +--------------------------------Wd--------------------------------+   \r\n    |      +-----------------------------Ds----------------------------+   \r\n    |      |        +----AN---+---------------AN---------------+---AN--+---\r\n    |      |        |         |                                |       |   \r\nLEFT-WALL the assignment.n type.n [denotes] [whether] [the] input.n tree.n \r\n\r\n\r\n-----------------Xp---------------------------------------------------\r\n                                                 +--------------------\r\n    +---------------------MVs--------------------+-----------Cs-------\r\n    +-----Os-----+                               |     +--------D*u---\r\nSs--+      +-D*u-+    +------------Xd------------+     |       +----AN\r\n    |      |     |    |                          |     |       |      \r\ndefines.v the value.n , [such] as.p [in] , or whether the attribute.n \r\n\r\n\r\n-----------------------------------+\r\n-Xc--------------------+           |\r\n----+                  |           |\r\n----+                  |           |\r\n----+----Ss---+--Ox--+ |           |\r\n    |         |      | |           |\r\ngrammar.n defines.v it , [as] [in] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "If an input tree fails to provide an input attribute, a runtime error will be thrown. To still provide an interpretation of such trees, input attributes  support the annotation ''?'',  which enables pattern matching through functions                                 and                           .  Alternatively, for the common scenario of using a fixed default value, a default value can instead be defined as in                          . If the input tree does not provide the value, the default value will be automatically substituted.", "errors": [{"i": [[338, 0, 180, 180, "''"], [338, 0, 185, 185, "which"], [338, 0, 191, 191, "enables"], [338, 0, 199, 199, "pattern"], [338, 0, 207, 207, "matching"], [338, 0, 216, 216, "through"], [338, 0, 224, 224, "functions"], [338, 0, 266, 266, "and"]], "s": " '',  which enables pattern matching through functions                \b                  and .\r\nNo complete linkages found.\r\nFound 4 linkages (4 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=4 AND=0 LEN=16)\r\n\r\n    +---------------------------------------Xp---------------------\r\n    |                         +--------------------Op--------------\r\n    |                         |         +---------------AN---------\r\n    +------Xx-----+           |         |          +----------A----\r\n    +---Wi---+    +-Ws+--Ss*w-+         |          |         +-----\r\n    |        |    |   |       |         |          |         |     \r\nLEFT-WALL ''[?].v , which enables.v pattern.n matching.g through.c \r\n\r\n\r\n------------------+\r\n-----+            |\r\n-----+            |\r\n-----+            |\r\nA----+            |\r\n     |            |\r\nfunctions.n [and] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[338, 0, 299, 299, "Alternatively"], [338, 0, 314, 314, "for"], [338, 0, 318, 318, "the"], [338, 0, 322, 322, "common"], [338, 0, 329, 329, "scenario"], [338, 0, 338, 338, "of"], [338, 0, 341, 341, "using"], [338, 0, 347, 347, "a"], [338, 0, 349, 349, "fixed"], [338, 0, 355, 355, "default"], [338, 0, 363, 363, "value"], [338, 0, 370, 370, "a"], [338, 0, 372, 372, "default"], [338, 0, 380, 380, "value"], [338, 0, 386, 386, "can"], [338, 0, 390, 390, "instead"], [338, 0, 398, 398, "be"], [338, 0, 401, 401, "defined"], [338, 0, 409, 409, "as"], [338, 0, 412, 412, "in"]], "s": " Alternatively, for the common scenario of using a fixed default valu \be, a default value can instead be defined as in .\r\nNo complete linkages found.\r\nFound 16 linkages (16 had no P.P. violations) at null count 3\r\n\tLinkage 1, cost vector = (UNUSED=3 DIS=2 AND=0 LEN=82)\r\n\r\n    +------------------------------------------------------------------------\r\n    +-----------------------------------------------------Wd-----------------\r\n    |           +-----------------------------------------------CO-----------\r\n    |           |           +-----------------------------------------CO-----\r\n    |           |           +--------------------------------Xc--------------\r\n    |           |           +----------Js---------+           +-------------O\r\n    |           |           |    +-------Ds-------+           |    +---------\r\n    |           |       +-Xd+    |      +----A----+--Mp--+-Mgp+    |    +----\r\n    |           |       |   |    |      |         |      |    |    |    |    \r\nLEFT-WALL alternatively , for.p the common.a scenario.n of using.v a fixed.v \r\n\r\n\r\n----Xp----------------------------------------------------------------------\r\n-----------------------------------+                                        \r\n-----------------------------------+                                        \r\n-----------------------------------+                                        \r\n------------------+                |                                        \r\ns------------+    |                |                                        \r\n-Dsu---------+    | +------Dsu-----+                                        \r\nA---+---AN---+    | |     +---AN---+--Ss--+-------Ix------+--Pv--+          \r\n    |        |    | |     |        |      |               |      |          \r\ndefault.n value.n , a default.n value.n can.v [instead] be.v defined.v [as] \r\n\r\n\r\n-----+\r\n     |\r\n     |\r\n     |\r\n     |\r\n     |\r\n     |\r\n     |\r\n     |\r\n[in] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Canonical attribute grammars can encode input attributes in two ways. First, semantic functions with no parameters encode the lack of dependencies. Second, for finite domains, the set of tree grammar productions can expand to include attribute nodes. The second encoding more faithfully describes our approach because, like our system, it feeds into an automatic tree parser generator. For each tree node, our generated parser scans for the expected set of input attributes.", "errors": [{"i": [[340, 0, 251, 251, "The"], [340, 0, 255, 255, "second"], [340, 0, 262, 262, "encoding"], [340, 0, 271, 271, "more"], [340, 0, 276, 276, "faithfully"], [340, 0, 287, 287, "describes"], [340, 0, 297, 297, "our"], [340, 0, 301, 301, "approach"], [340, 0, 310, 310, "because"], [340, 0, 319, 319, "like"], [340, 0, 324, 324, "our"], [340, 0, 328, 328, "system"], [340, 0, 336, 336, "it"], [340, 0, 339, 339, "feeds"], [340, 0, 345, 345, "into"], [340, 0, 350, 350, "an"], [340, 0, 353, 353, "automatic"], [340, 0, 363, 363, "tree"], [340, 0, 368, 368, "parser"], [340, 0, 375, 375, "generator"]], "s": " The second encoding more faithfully describes our approach because,  \blike our system, it feeds into an automatic tree parser generator.\r\nNo complete linkages found.\r\nFound 70 linkages (70 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=4 AND=0 LEN=48)\r\n\r\n    +------------------------------------------------------------------------\r\n    |                                                                        \r\n    |                                                                        \r\n    |                                                  +-----------MVs-------\r\n    +------Wd-----+-----------------Ss-----------------+-------Os------+     \r\n    |      +--Ds--+----Mg---+---Om--+       +----Em----+       +---Ds--+     \r\n    |      |      |         |       |       |          |       |       |     \r\nLEFT-WALL the second.n encoding.v more faithfully describes.v our approach.n \r\n\r\n\r\n----------Xp------------------------------------------------------------\r\n   +--------------Cs-------------+                                      \r\n   |         +--------COd--------+                                      \r\n---+         +-------Xc-------+  |    +-----------------------Os--------\r\n   |         +-----Js----+    |  |    |            +----------------Ds--\r\n   |    +-Xd-+    +--Ds--+    |  +-Ss-+            |      +----A----+---\r\n   |    |    |    |      |    |  |    |            |      |         |   \r\nbecause , like.p our system.n , it feeds.v [into] an automatic.a tree.n \r\n\r\n\r\n---------------------+\r\n                     |\r\n                     |\r\n--------------+      |\r\n--------------+      |\r\nAN--+----AN---+      |\r\n    |         |      |\r\nparser.n generator.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "      \\textbf{Value types.} \nThe system also supports type annotations used for embeddings. Generated code typically compiles as part of a project in a more static language, such as C++, which require a static type discipline. The annotations can be user-defined, such as OpenGL's \\emph{vertex buffer object}           , which is not defined within our system.", "errors": [{"i": [342, 1, 51, 80, "embeddings"], "s": ["embedding", "embed dings", "embed-dings"], "e": "spell"}, {"i": [342, 1, 243, 272, "OpenGL's"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Our analyzer ignores the value type annotations such as                  and                while the low-level code generator passes along the decorations              and           .  The embedded design simplifies implementation because value type checking is performed by the host language's compiler. \n             ", "errors": [{"i": [[345, 0, 0, 0, "Our"], [345, 0, 4, 4, "analyzer"], [345, 0, 13, 13, "ignores"], [345, 0, 21, 21, "the"], [345, 0, 25, 25, "value"], [345, 0, 31, 31, "type"], [345, 0, 36, 36, "annotations"], [345, 0, 48, 48, "such"], [345, 0, 53, 53, "as"], [345, 0, 73, 73, "and"], [345, 0, 92, 92, "while"], [345, 0, 98, 98, "the"], [345, 0, 102, 102, "low-level"], [345, 0, 112, 112, "code"], [345, 0, 117, 117, "generator"], [345, 0, 127, 127, "passes"], [345, 0, 134, 134, "along"], [345, 0, 140, 140, "the"], [345, 0, 144, 144, "decorations"], [345, 0, 169, 169, "and"]], "s": " Our analyzer ignores the value type annotations such as              \b     and                while the low-level code generator passes along the deco \brations              and .\r\nNo complete linkages found.\r\nFound 54 linkages (30 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=1 AND=0 LEN=39)\r\n\r\n    +-------------------------------------------------------------------------\r\n    |                           +----------------------MVs--------------------\r\n    |                           +--------------Op--------------+              \r\n    +-------Wd------+           |      +----------Dmc----------+              \r\n    |      +---D*u--+-----Ss----+      |     +---AN--+----AN---+              \r\n    |      |        |           |      |     |       |         |              \r\nLEFT-WALL our analyzer[?].n ignores.v the value.n type.n annotations.n [such] \r\n\r\n\r\n---------Xp-------------------------------------------------------------\r\n--+                                                                     \r\n  +---------------------Cs--------------------+                         \r\n  |             +--------------Ds-------------+                 +------J\r\n  |             |         +----Ah----+---AN---+----Ss----+--MVp-+    +--\r\n  |             |         |          |        |          |      |    |  \r\nas.p and while the low-level[!].a code.n generator.n passes.v along the \r\n\r\n\r\n--------------------+\r\n                    |\r\n                    |\r\np-----+             |\r\n-Dmc--+             |\r\n      |             |\r\ndecorations.n [and] . \r\n\r\n\r\n    +-------------------------------------------------------------------------\r\n    |                           +---------------------------MVs---------------\r\n    |                           +--------------Op--------------+              \r\n    +-------Wd------+           |      +----------Dmc----------+              \r\n    |      +---D*u--+-----Ss----+      |     +---AN--+----AN---+              \r\n    |      |        |           |      |     |       |         |              \r\nLEFT-WALL our analyzer[?].n ignores.v the value.n type.n annotations.n [such] \r\n\r\n\r\n---------Xp-------------------------------------------------------------\r\n-----------+                                                            \r\n           +----------------Cs----------------+                         \r\n           |    +--------------Ds-------------+                 +------J\r\n           |    |         +----Ah----+---AN---+----Ss----+--MVp-+    +--\r\n           |    |         |          |        |          |      |    |  \r\nas.p and while the low-level[!].a code.n generator.n passes.v along the \r\n\r\n\r\n--------------------+\r\n                    |\r\n                    |\r\np-----+             |\r\n-Dmc--+             |\r\n      |             |\r\ndecorations.n [and] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "In practice, we  use attribute definitions in interfaces for information hiding across classes and lightweight specification of relationships between similar classes. An attribute declared inside of a class is \\emph{local} to constraints in the class: only the class's constraints can read or write to the attribute. Conversely, declaring a \\emph{var} inside of an interface hints that it is meant to be reused by outside classes, such as part of a tree traversal.", "errors": [{"i": [348, 0, 261, 261, "class's"], "s": ["classes", "lass's"], "e": "spell"}, {"i": [348, 0, 347, 347, "var"], "s": ["bar", "car", "ear", "far", "jar", "mar", "oar", "par", "tar", "van", "VAR", "vary", "vat", "Vax", "VCR", "war"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\caption{\\textbf{Trait construct}. Adds shared rendering code to the HBox class.}\n                 \n            ", "errors": [{"i": [358, 0, 69, 69, "HBox"], "s": ["Box"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsection{Traits: Reusing Cross-cutting Code}\nAs with many object systems, we support a trait construct for cross-cutting code that should be shared across classes. It statically expands like a macro, and therefore provides no formal expressive power. For example, Figure~\\ref{fig:trait} defines how to render a rectangle given several attributes, and then adds that functionality to class            . If the language was extended with class            , the class definition of             could also use trait                 .", "errors": [{"i": [[362, 0, 12, 12, "Traits"], [362, 0, 20, 20, "Reusing"], [362, 0, 28, 28, "Cross-cutting"], [362, 0, 42, 42, "Code"]], "s": " Traits: Reusing Cross-cutting Code.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 7\r\n\tUnique linkage, cost vector = (UNUSED=8 DIS=0 AND=0 LEN=0)\r\n\r\n[Traits] [:] [reusing] [Cross-cutting] [Code] [.] \r\n\r\n", "e": "gram"}, {"i": [[362, 1, 206, 254, "For"], [362, 1, 210, 258, "example"], [362, 1, 219, 267, "Figure"], [362, 1, 231, 279, "fig"], [362, 1, 235, 283, "trait"], [362, 1, 242, 290, "defines"], [362, 1, 250, 298, "how"], [362, 1, 254, 302, "to"], [362, 1, 257, 305, "render"], [362, 1, 264, 312, "a"], [362, 1, 266, 314, "rectangle"], [362, 1, 276, 324, "given"], [362, 1, 282, 330, "several"], [362, 1, 290, 338, "attributes"], [362, 1, 302, 350, "and"], [362, 1, 306, 354, "then"], [362, 1, 311, 359, "adds"], [362, 1, 316, 364, "that"], [362, 1, 321, 369, "functionality"], [362, 1, 335, 383, "to"], [362, 1, 338, 386, "class"]], "s": " For example, Figure~\\ref{fig:trait defines how to render a rectangle \b given several attributes, and then adds that functionality to class .\r\nNo complete linkages found.\r\nFound 11 linkages (11 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=5 AND=2 LEN=57)\r\n\r\n    +-------------------------------------------------------------------------\r\n    +--------------Wd-------------+               +---------------------------\r\n    |            +-------CO-------+               |                    +-----O\r\n    |      +IDBXA+-Xc-+           +-------Ss------+-----MVi-----+---I--+    +-\r\n    |      |     |    |           |               |             |      |    | \r\nLEFT-WALL for example , Figure~\\ref{fig:trait defines.v [how] to.r render.v a \r\n\r\n\r\n--------------Xp---------------------------------------------------------\r\n--Opn-----------------------------+                                      \r\ns----+                            |                                      \r\n-Ds--+----Mv---+       +----Dmc---+                                      \r\n     |         |       |          |                                      \r\nrectangle.n given.v several attributes.n , and then.r adds.v that.misc-d \r\n\r\n\r\n-----------------------------+\r\n                             |\r\n                             |\r\n                             |\r\n                             |\r\nfunctionality.n to.r class.n . \r\n\r\n\r\n    +-------------------------------------------------------------------------\r\n    +--------------Wd-------------+                                           \r\n    |            +-------CO-------+-------------------------------------------\r\n    |      +IDBXA+-Xc-+           |                                           \r\n    |      |     |    |           |                                           \r\nLEFT-WALL for example , Figure~\\ref{fig:trait defines.v [how] to.r render.v a \r\n\r\n\r\n--------------Xp---------------------------------------------------------\r\n                                                         +---------------\r\n------Ss-------------------------------------------------+----------Os---\r\n                                                  +---E--+        +-----D\r\n                                                  |      |        |      \r\nrectangle.n given.v several attributes.n , and then.r adds.v that.misc-d \r\n\r\n\r\n-----------------------------+\r\nMVp---------------+          |\r\n-------+          |          |\r\n*u-----+          +--Jp-+    |\r\n       |          |     |    |\r\nfunctionality.n to.r class.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[362, 1, 357, 405, "If"], [362, 1, 360, 408, "the"], [362, 1, 364, 412, "language"], [362, 1, 373, 421, "was"], [362, 1, 377, 425, "extended"], [362, 1, 386, 434, "with"], [362, 1, 391, 439, "class"], [362, 1, 410, 458, "the"], [362, 1, 414, 462, "class"], [362, 1, 420, 468, "definition"], [362, 1, 431, 479, "of"], [362, 1, 446, 494, "could"], [362, 1, 452, 500, "also"], [362, 1, 457, 505, "use"], [362, 1, 461, 509, "trait"]], "s": " If the language was extended with class            , the class defin \bition of             could also use trait .\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 3\r\n\tUnique linkage, cost vector = (UNUSED=3 DIS=1 AND=0 LEN=17)\r\n\r\n                                                           +-----------------\r\n                                             +-----MXs-----+-----------------\r\n                                             |    +---Xd---+                 \r\n      +--D*u--+---Ss--+---Pv---+--MVp--+--Jp-+    |  +-D*u-+----Rn----+------\r\n      |       |       |        |       |     |    |  |     |          |      \r\n[if] the language.n was.v extended.v with class.n , the class.n definition.n \r\n\r\n\r\n-------Xc-----------------------+\r\n-Bs-----------------+           |\r\n        +-----I-----+           |\r\nSs------+      +--E-+           |\r\n        |      |    |           |\r\n[of] could.v also use.v [trait] . \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\caption{\\textbf{Input tree as graph with labeled nodes and edges}. Specified in the JSON notation.}\n                 \n            ", "errors": [{"i": [[392, 0, 17, 17, "Input"], [392, 0, 23, 23, "tree"], [392, 0, 28, 28, "as"], [392, 0, 31, 31, "graph"], [392, 0, 37, 37, "with"], [392, 0, 42, 42, "labeled"], [392, 0, 50, 50, "nodes"], [392, 0, 56, 56, "and"], [392, 0, 60, 60, "edges"]], "s": " Input tree as graph with labeled nodes and edges.\r\nNo complete linkages found.\r\nFound 2 linkages (2 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=2 AND=3 LEN=18)\r\n\r\n    +----------------------------------Xp----------------------------------+\r\n    |        +---------------------Op---------------------+                |\r\n    |        |                   +-----------AN-----------+                |\r\n    +---Wi---+       +-----AN----+               +----A---+                |\r\n    |        |       |           |               |        |                |\r\nLEFT-WALL input.v tree.n [as] graph.n [with] labeled.v nodes.n and edges.n . \r\n\r\n\r\n    +----------------------------------Xp----------------------------------+\r\n    +---Wi---+---------------------------Op---------------------------+    |\r\n    |        |                                                        |    |\r\nLEFT-WALL input.v tree.n [as] graph.n [with] labeled.v nodes.n and edges.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[392, 0, 68, 68, "Specified"], [392, 0, 78, 78, "in"], [392, 0, 81, 81, "the"], [392, 0, 85, 85, "JSON"], [392, 0, 90, 90, "notation"]], "s": " Specified in the JSON notation.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 7\r\n\tUnique linkage, cost vector = (UNUSED=8 DIS=0 AND=0 LEN=0)\r\n\r\n[specified] [in] [the] [JSON] [notation] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsection{Loops}\nWe extend our language with declarative loops over the attributes of multiple nodes. They are an expressive extension over the uniform recurrence relations of [[CITE]].", "errors": [{"i": [[396, 0, 12, 12, "Loops"]], "s": " Loops.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 3\r\n\tUnique linkage, cost vector = (UNUSED=4 DIS=0 AND=0 LEN=0)\r\n\r\n[loops] [.] \r\n\r\n", "e": "gram"}, {"i": [[396, 1, 0, 19, "We"], [396, 1, 3, 22, "extend"], [396, 1, 10, 29, "our"], [396, 1, 14, 33, "language"], [396, 1, 23, 42, "with"], [396, 1, 28, 47, "declarative"], [396, 1, 40, 59, "loops"], [396, 1, 46, 65, "over"], [396, 1, 51, 70, "the"], [396, 1, 55, 74, "attributes"], [396, 1, 66, 85, "of"], [396, 1, 69, 88, "multiple"], [396, 1, 78, 97, "nodes"]], "s": " We extend our language with declarative loops over the attributes of \b multiple nodes.\r\nNo complete linkages found.\r\nFound 10 linkages (4 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=0 AND=0 LEN=18)\r\n\r\n    +----------------------------------------------------Xp----------------\r\n    |            +------Os-----+                                    +-----J\r\n    +--Wd--+--Sp-+     +--D*u--+--------Ma--------+-------MVp-------+   +--\r\n    |      |     |     |       |                  |                 |   |  \r\nLEFT-WALL we extend.v our language.n [with] declarative.a [loops] over the \r\n\r\n\r\n-----------------------------------+\r\np-----+       +-------Jp------+    |\r\n-Dmc--+---Mp--+      +----A---+    |\r\n      |       |      |        |    |\r\nattributes.n of multiple.a nodes.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[396, 1, 85, 104, "They"], [396, 1, 90, 109, "are"], [396, 1, 94, 113, "an"], [396, 1, 97, 116, "expressive"], [396, 1, 108, 127, "extension"], [396, 1, 118, 137, "over"], [396, 1, 123, 142, "the"], [396, 1, 127, 146, "uniform"], [396, 1, 135, 154, "recurrence"], [396, 1, 146, 165, "relations"], [396, 1, 156, 175, "of"], [396, 1, 161, 180, "CITE"]], "s": " They are an expressive extension over the uniform recurrence relatio \bns of [[CITE].\r\nNo complete linkages found.\r\nFound 24 linkages (24 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=0 AND=0 LEN=29)\r\n\r\n    +----------------------------------------------------Xp---------\r\n    |            +---------------MVp---------------+                \r\n    |            +-----------Ost----------+        +----------------\r\n    |            |    +--------Dsu--------+        |   +------------\r\n    +---Wd--+-Spx+    |       +-----A-----+        |   |      +-----\r\n    |       |    |    |       |           |        |   |      |     \r\nLEFT-WALL they are.v an expressive.a extension.n over the uniform.a \r\n\r\n\r\n-------------------------------------------+\r\n                                           |\r\nJp----------------+                        |\r\n--Dmc-------------+--------MXp--------+    |\r\nA-----+-----AN----+               +-Xd+Xc+ |\r\n      |           |               |   |  | |\r\nrecurrence.n relations.n [of] [[] [ CITE ] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "The loop construct,            , specifies a block of loop body statements. It acts over a sequence of nodes declared with the same interface, such as                          in Figure~\\ref{fig:loops}. The looping order is restricted to forward iteration, though our approach generalizes to other loop orders.", "errors": [{"i": [[399, 0, 0, 0, "The"], [399, 0, 4, 4, "loop"], [399, 0, 9, 9, "construct"], [399, 0, 33, 33, "specifies"], [399, 0, 43, 43, "a"], [399, 0, 45, 45, "block"], [399, 0, 51, 51, "of"], [399, 0, 54, 54, "loop"], [399, 0, 59, 59, "body"], [399, 0, 64, 64, "statements"]], "s": " The loop construct,            , specifies a block of loop body stat \bements.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 4\r\n\tUnique linkage, cost vector = (UNUSED=4 DIS=2 AND=0 LEN=20)\r\n\r\n    +-------------------------------------------Xp-----------------------\r\n    +----------Wd---------+                   +-----Os----+     +--------\r\n    |      +------Ds------+---------Ss--------+      +-Ds-+--Mp-+        \r\n    |      |              |                   |      |    |     |        \r\nLEFT-WALL the [loop] construct.n [,] [,] specifies.v a block.n of [loop] \r\n\r\n\r\n--------------------+\r\n--Jp---------+      |\r\n   +----AN---+      |\r\n   |         |      |\r\nbody.n statements.n . \r\n\r\n", "e": "gram"}, {"i": [[399, 0, 76, 76, "It"], [399, 0, 79, 79, "acts"], [399, 0, 84, 84, "over"], [399, 0, 89, 89, "a"], [399, 0, 91, 91, "sequence"], [399, 0, 100, 100, "of"], [399, 0, 103, 103, "nodes"], [399, 0, 109, 109, "declared"], [399, 0, 118, 118, "with"], [399, 0, 123, 123, "the"], [399, 0, 127, 127, "same"], [399, 0, 132, 132, "interface"], [399, 0, 143, 143, "such"], [399, 0, 148, 148, "as"], [399, 0, 176, 176, "in"], [399, 0, 179, 179, "Figure"], [399, 0, 191, 191, "fig"], [399, 0, 195, 195, "loops"]], "s": " It acts over a sequence of nodes declared with the same interface, s \buch as                          in Figure~\\ref{fig:loops.\r\nNo complete linkages found.\r\nFound 92 linkages (92 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=1 AND=0 LEN=9)\r\n\r\n                                                                     +-----MXs\r\n            +----Jp---+                             +-------Js-------+      +-\r\n +-Ss-+-MVp-+  +--Dsu-+--Mp--+-Jp-+----Mv---+--MVp--+   +IDBR+--Ds*y-+      | \r\n |    |     |  |      |      |    |         |       |   |    |       |      | \r\nit acts.v over a sequence.n of nodes.n declared.v with the same interface.n , \r\n\r\n\r\nx-----+                             \r\n--Xd--+-------------Xc-------------+\r\n  +IDB+--------J-------+           |\r\n  |   |                |           |\r\nsuch as [in] Figure~\\ref{fig:loops . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[399, 0, 203, 203, "The"], [399, 0, 207, 207, "looping"], [399, 0, 215, 215, "order"], [399, 0, 221, 221, "is"], [399, 0, 224, 224, "restricted"], [399, 0, 235, 235, "to"], [399, 0, 238, 238, "forward"], [399, 0, 246, 246, "iteration"], [399, 0, 257, 257, "though"], [399, 0, 264, 264, "our"], [399, 0, 268, 268, "approach"], [399, 0, 277, 277, "generalizes"], [399, 0, 289, 289, "to"], [399, 0, 292, 292, "other"], [399, 0, 298, 298, "loop"], [399, 0, 303, 303, "orders"]], "s": " The looping order is restricted to forward iteration, though our app \broach generalizes to other loop orders.\r\nNo complete linkages found.\r\nFound 18 linkages (18 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=2 AND=0 LEN=19)\r\n\r\n                                 +------------------MVs------------------+----\r\n +------D*u------+               +------MVp------+                       +----\r\n |      +----A---+--Ss--+---Pv---+---MVp--+      |                 +--Xd-+    \r\n |      |        |      |        |        |      |                 |     |    \r\nthe looping.g order.n is.v restricted.v to.r forward.r [iteration] , though.c \r\n\r\n\r\n-------------------------Xc-----------------------------+\r\n--Cs-----+                     +---------Jp--------+    |\r\n +---Ds--+-----Ss----+---MVp---+    +------Dmc-----+    |\r\n |       |           |         |    |              |    |\r\nour approach.n generalizes.v to.r other [loop] orders.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "A statement in a loop body will execute for each element of the list. For example, the following statement assigns the attribute          the sum of the children widths:\n                                             \nSimilar to array index notation, the suffix on righthand-side variable names for loop statements provide a restricted form of relative indexing for loops. In particular:\n               \n       $i: the ``current'' loop step\n       $-: the previous loop step\n       $ $: the last loop step\n             \nUse of suffix `` $-'' in a             can be thought of as an accumulator in functional programming. ", "errors": [{"i": [401, 2, 47, 263, "righthand-side"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "One loop statement can refer to the accumulator of another, which fold statements in most languages do not support. For example, two loop counters can be intertwined:\n                                                                                                                                                                        ", "errors": [{"i": [[412, 0, 0, 0, "One"], [412, 0, 4, 4, "loop"], [412, 0, 9, 9, "statement"], [412, 0, 19, 19, "can"], [412, 0, 23, 23, "refer"], [412, 0, 29, 29, "to"], [412, 0, 32, 32, "the"], [412, 0, 36, 36, "accumulator"], [412, 0, 48, 48, "of"], [412, 0, 51, 51, "another"], [412, 0, 60, 60, "which"], [412, 0, 66, 66, "fold"], [412, 0, 71, 71, "statements"], [412, 0, 82, 82, "in"], [412, 0, 85, 85, "most"], [412, 0, 90, 90, "languages"], [412, 0, 100, 100, "do"], [412, 0, 103, 103, "not"], [412, 0, 107, 107, "support"]], "s": " One loop statement can refer to the accumulator of another, which fo \bld statements in most languages do not support.\r\nNo complete linkages found.\r\nFound 80 linkages (20 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=1 AND=0 LEN=25)\r\n\r\n                                       +------Js------+              +--MXsr\r\n +------Ds------+--Ss*t--+---I--+--MVp-+   +----Ds----+----Mp---+-Js-+    +-\r\n |              |        |      |      |   |          |         |    |    | \r\none [loop] statement.n can.v refer.v to.r the accumulator[!].n of another , \r\n\r\n\r\n  +------------------------------Xc------------------------------+\r\n  +---------------------------B*w--------------------------+     |\r\n  |                +------------Sp*t------------+          |     |\r\n--+                |       +-----Jp----+        +----I*d---+     |\r\nXd+      +----AN---+---Mp--+   +--Dmc--+        +-N-+      |     |\r\n  |      |         |       |   |       |        |   |      |     |\r\nwhich fold.n statements.n in most languages.n do.v not support.v . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[412, 0, 116, 116, "For"], [412, 0, 120, 120, "example"], [412, 0, 129, 129, "two"], [412, 0, 133, 133, "loop"], [412, 0, 138, 138, "counters"], [412, 0, 147, 147, "can"], [412, 0, 151, 151, "be"], [412, 0, 154, 154, "intertwined"]], "s": " For example, two loop counters can be intertwined:.\r\nNo complete linkages found.\r\nFound 2 linkages (2 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=0 AND=0 LEN=19)\r\n\r\n    +----------------------------------Xp----------------------------------+\r\n    +-----------------Wd----------------+                                  |\r\n    |            +----------CO----------+                                  |\r\n    |      +IDBXA+-Xc-+  +------Dmc-----+---Sp--+--Ix-+---Pv---+           |\r\n    |      |     |    |  |              |       |     |        |           |\r\nLEFT-WALL for example , two [loop] counters.n can.v be.v intertwined.v [:] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "The programmer does not need to order the statements.  For example, our system infers that the imperative code that implements the above declarations is just one imperative loop that fuses them together. The incorrect alternative of implementing the declarations as a different imperative loop for each would lead to unfulfilled data dependencies. The freedom in statement order supports automatic parallelization, but also allowed programmers choice in how to structure the program once machine considerations were removed.", "errors": [{"i": [[421, 0, 204, 204, "The"], [421, 0, 208, 208, "incorrect"], [421, 0, 218, 218, "alternative"], [421, 0, 230, 230, "of"], [421, 0, 233, 233, "implementing"], [421, 0, 246, 246, "the"], [421, 0, 250, 250, "declarations"], [421, 0, 263, 263, "as"], [421, 0, 266, 266, "a"], [421, 0, 268, 268, "different"], [421, 0, 278, 278, "imperative"], [421, 0, 289, 289, "loop"], [421, 0, 294, 294, "for"], [421, 0, 298, 298, "each"], [421, 0, 303, 303, "would"], [421, 0, 309, 309, "lead"], [421, 0, 314, 314, "to"], [421, 0, 317, 317, "unfulfilled"], [421, 0, 329, 329, "data"], [421, 0, 334, 334, "dependencies"]], "s": " The incorrect alternative of implementing the declarations as a diff \berent imperative loop for each would lead to unfulfilled data dependencies.\r\nNo complete linkages found.\r\nFound 8184 linkages (16 of 1000 random linkages had no P.P. violations) at null count 3\r\n\tLinkage 1, cost vector = (UNUSED=3 DIS=1 AND=0 LEN=43)\r\n\r\n    +------------------------------------------------------------------------\r\n    +-------------Wd------------+--------------------------------------------\r\n    |      +---------Ds---------+                 +--------Op--------+-------\r\n    |      |       +------A-----+---Mp---+---Mgp--+        +---Dmc---+       \r\n    |      |       |            |        |        |        |         |       \r\nLEFT-WALL the incorrect.a alternative.n of implementing.v the declarations.n \r\n\r\n\r\n-----------------Xp-----------------------------------------------------\r\n-----Ss------------------------------------------------+                \r\n---------Ma----------------+                           |             +--\r\n  +-----------EAy----------+------MVp------+--Js-+     +---I---+-MVp-+  \r\n  |                        |               |     |     |       |     |  \r\nas.y [a] [different] imperative.a [loop] for.p each would.v lead.v to.r \r\n\r\n\r\n------------------------------------+\r\n                                    |\r\n------------Jp--------------+       |\r\n      +-----A----+----AN----+       |\r\n      |          |          |       |\r\nunfulfilled.a data.n dependencies.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "We reduced scheduling loops to scheduling canonical attribute grammars. Our insight is that, for a restricted language of relative indices, we can schedule several unrolled loop steps and generalize the schedule to the rest. Section~\\ref{???} discusses this in more detail. ", "errors": [{"i": [[423, 0, 0, 0, "We"], [423, 0, 3, 3, "reduced"], [423, 0, 11, 11, "scheduling"], [423, 0, 22, 22, "loops"], [423, 0, 28, 28, "to"], [423, 0, 31, 31, "scheduling"], [423, 0, 42, 42, "canonical"], [423, 0, 52, 52, "attribute"], [423, 0, 62, 62, "grammars"]], "s": " We reduced scheduling loops to scheduling canonical attribute gramma \brs.\r\nNo complete linkages found.\r\nFound 21 linkages (20 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=4 AND=0 LEN=13)\r\n\r\n    +---------------------------------------------Xp----------------------\r\n    |            +-------------MVp------------+        +-----------------O\r\n    +--Wd--+--Sp-+-----Os----+                +---Mgp--+           +-----A\r\n    |      |     |           |                |        |           |      \r\nLEFT-WALL we reduced.v scheduling.g [loops] to.r scheduling.v canonical.a \r\n\r\n\r\n-----------------------+\r\np----------------+     |\r\n-----+-----AN----+     |\r\n     |           |     |\r\nattribute.n grammars.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[423, 0, 225, 225, "Section"]], "s": " Section~.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 3\r\n\tUnique linkage, cost vector = (UNUSED=4 DIS=0 AND=0 LEN=0)\r\n\r\n[Section~] [.] \r\n\r\n", "e": "gram"}, {"i": [[423, 0, 243, 243, "discusses"], [423, 0, 253, 253, "this"], [423, 0, 258, 258, "in"], [423, 0, 261, 261, "more"], [423, 0, 266, 266, "detail"]], "s": " discusses this in more detail.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 7\r\n\tUnique linkage, cost vector = (UNUSED=8 DIS=0 AND=0 LEN=0)\r\n\r\n[discusses] [this] [in] [more] [detail] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsection{Embedded Domain Specific Language: Functional Rendering}\nWe designed our system for interaction with other tools and languages. A key ability is to invoke externally-defined functions, such as               of Figure~\\ref{fig:loops} for the maximum of two numbers and                    of Figure~\\ref{fig:trait} to draw a rectangle to the screen. Attribute grammars are compiled to run in some host system, such as JavaScript or OpenCL, and any function in scope to the generated code may be called.", "errors": [{"i": [425, 1, 359, 428, "JavaScript"], "s": ["Java Script", "Java-Script"], "e": "spell"}, {"i": [425, 1, 373, 442, "OpenCL"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Functions can be safely embedded as long as they provide a \\emph{pure} interface. In particular, the returned output should only depend on the inputs. Likewise, functions should be reentrant for use in automatic parallelization In the case of embedding in statically checked languages, the host's static checker is responsible for checking usage.", "errors": [], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "              \n                                                            \n                                           \n\\includegraphics[trim=0 0 0 0,clip,width=1.0\\columnwidth]{chapter2/sunburst}\n              }\n                                                          \n                                           \n\\includegraphics[trim=0 0 0 0,clip,width=1.0\\columnwidth]{chapter2/election}\n              }  \n                                                                \n                                           \n\\includegraphics[trim=0 150mm 0 0,clip,width=1.0\\columnwidth]{chapter2/parlabscreenshot2}\n              }\n                                                                     \n                                           \n\\includegraphics[trim=0 0 0 0,clip,width=1.0\\columnwidth]{chapter2/ge}\n              }  \n                                                          \n                                           \n\\includegraphics[trim=0 0 0 0,clip,width=0.35\\columnwidth]{chapter2/line}\n              }\n\\caption{\\textbf{Visualization screenshots.} All except [[CITE]] are interactive or animated. Each one was declaratively specified with our extended form of attribute grammars and automatically parallelized. Labels describe whether GPU or multicore code generation was used.}\n                         \n            ", "errors": [{"i": [432, 21, 31, 1053, "screenshots"], "s": ["screen shots", "screen-shots"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "              \n                                                                          \n                                           \n\\includegraphics[trim=0 0 0 0,clip,width=0.3\\columnwidth]{chapter2/table}\n              }  \n                                                               \n                                           \n\\includegraphics[trim=0 0 0 0,clip,width=0.8\\columnwidth]{chapter2/wiki}\n              }\n\\caption{\\textbf{Document layout screenshots.}}\n                         \n            ", "errors": [{"i": [457, 9, 33, 456, "screenshots"], "s": ["screen shots", "screen-shots"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\section{Evaluation: Mechanized Layout Features}\nWe specified many common layout language features with our extended form of attribute grammars. Most examples were written with few, if any, modifications to the generated code. This experience shows that our restricted form of attribute grammars are a viable formalism for layout specification. The following subsections present highlights from our case studies in specifying layouts with attribute grammars, and the appendix contains the full code.", "errors": [{"i": [[473, 0, 9, 9, "Evaluation"], [473, 0, 21, 21, "Mechanized"], [473, 0, 32, 32, "Layout"], [473, 0, 39, 39, "Features"]], "s": " Evaluation: Mechanized Layout Features.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 1\r\n\tUnique linkage, cost vector = (UNUSED=1 DIS=0 AND=0 LEN=7)\r\n\r\n    +------------------------Xp-----------------------+\r\n    |                          +--------Os-------+    |\r\n    +----Wd----+-------Ss------+         +---G---+    |\r\n    |          |               |         |       |    |\r\nLEFT-WALL Evaluation [:] mechanized.v Layout Features . \r\n\r\n", "e": "gram"}, {"i": [[473, 1, 96, 145, "Most"], [473, 1, 101, 150, "examples"], [473, 1, 110, 159, "were"], [473, 1, 115, 164, "written"], [473, 1, 123, 172, "with"], [473, 1, 128, 177, "few"], [473, 1, 133, 182, "if"], [473, 1, 136, 185, "any"], [473, 1, 141, 190, "modifications"], [473, 1, 155, 204, "to"], [473, 1, 158, 207, "the"], [473, 1, 162, 211, "generated"], [473, 1, 172, 221, "code"]], "s": " Most examples were written with few, if any, modifications to the ge \bnerated code.\r\nNo complete linkages found.\r\nFound 6 linkages (6 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=1 AND=0 LEN=15)\r\n\r\n                                                              +-------------\r\n                                       +----------MXp---------+          +--\r\n                                       +----MXp---+           |          |  \r\n  +--Dmc--+---Spx--+---Pv--+--MVp--+-Jp+  +---Xd--+Xc+---Xd---+----Mp----+  \r\n  |       |        |       |       |   |  |       |  |        |          |  \r\nmost examples.n were.v written.v with few , [if] any , modifications.n to.r \r\n\r\n\r\n----Xc-----------------+\r\n--------Jp---------+   |\r\n +-------D*u-------+   |\r\n |       +----A----+   |\r\n |       |         |   |\r\nthe generated.v code.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsection{Rendering}\n                     \nWe found several rendering patterns to be important for many visualizations. A library of functional graphics primitives, such as                  in Figure~\\ref{fig:trait}, sufficiently augmented our attribute grammar language in order to achieve them.", "errors": [{"i": [[476, 0, 12, 12, "Rendering"]], "s": " Rendering.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 3\r\n\tUnique linkage, cost vector = (UNUSED=4 DIS=0 AND=0 LEN=0)\r\n\r\n[Rendering] [.] \r\n\r\n", "e": "gram"}, {"i": [[476, 2, 77, 122, "A"], [476, 2, 79, 124, "library"], [476, 2, 87, 132, "of"], [476, 2, 90, 135, "functional"], [476, 2, 101, 146, "graphics"], [476, 2, 110, 155, "primitives"], [476, 2, 122, 167, "such"], [476, 2, 127, 172, "as"], [476, 2, 147, 192, "in"], [476, 2, 150, 195, "Figure"], [476, 2, 162, 207, "fig"], [476, 2, 166, 211, "trait"], [476, 2, 174, 219, "sufficiently"], [476, 2, 187, 232, "augmented"], [476, 2, 197, 242, "our"], [476, 2, 201, 246, "attribute"], [476, 2, 211, 256, "grammar"], [476, 2, 219, 264, "language"], [476, 2, 228, 273, "in"], [476, 2, 231, 276, "order"], [476, 2, 237, 282, "to"], [476, 2, 240, 285, "achieve"], [476, 2, 248, 293, "them"]], "s": " A library of functional graphics primitives, such as                 \b  in Figure~\\ref{fig:trait, sufficiently augmented our attribute grammar languag \be in order to achieve them.\r\nNo complete linkages found.\r\nFound 64 linkages (64 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=3 AND=0 LEN=53)\r\n\r\n    +------------------------------------------------------------------------\r\n    |           +--------------------------------------------------Ss--------\r\n    |           |      +---------------Jp--------------+-----MXpx-----+      \r\n    +-----Wd----+      |       +-----------A-----------+      +---Xd--+------\r\n    |     +--Ds-+--Mp--+       |           +-----AN----+      |   +IDB+------\r\n    |     |     |      |       |           |           |      |   |   |      \r\nLEFT-WALL a library.n of functional.a graphics.n primitives.n , such as [in] \r\n\r\n\r\n----------------------Xp---------------------------------------------------\r\n------------------------------------------+---------------------MVp--------\r\n                                          +------------------Os------------\r\n-------Xc-------------+                   |       +-------------D*u--------\r\n-Js-------+           |       +-----E-----+       |       +----AN----+----A\r\n          |           |       |           |       |       |          |     \r\nFigure~\\ref{fig:trait , sufficiently augmented.v our attribute.n grammar.n \r\n\r\n\r\n------------------------------------------+\r\n------------+                             |\r\n-----+      |                             |\r\n-----+      |                             |\r\nN----+      +-Jp-+--TOn-+---I--+---Ox--+  |\r\n     |      |    |      |      |       |  |\r\nlanguage.n in order.n to.r achieve.v them . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "               \n      \\textbf{2D and 3D.} Our base primitives are 3D, and we provide 2D primitives that reduce into them. \n      \\textbf{Color.} Our functional graphics primitives take an RGBA value as input, which enables controlling hue, luminosity, and opacity.\n      \\textbf{Linked view}. Multiple renderable objects can be associated with one node, which we can use for providing different views of the same data. Such functionality is common for statistical analysis software:", "errors": [{"i": [480, 2, 65, 188, "RGBA"], "s": [], "e": "spell"}, {"i": [480, 3, 37, 302, "renderable"], "s": ["render able", "render-able"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "      \\textbf{Zooming.} We can use the same multiple representation capability for a live zoomed out view (``picture-in-picture''):", "errors": [{"i": [489, 0, 109, 109, "picture-in-picture'')"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "      \\textbf{Visibility toggles.} Our macros support conditional expressions, which enables controlling whether to render an object. For example, a boolean input attribute can control whether to show a circle:                                             \n      \\textbf{Alternative representations.} Conditional expressions also enable choosing between multiple representations, not just on/off visibility:\n                                                                                                                                    ", "errors": [{"i": [[497, 0, 14, 14, "Visibility"], [497, 0, 25, 25, "toggles"]], "s": " Visibility toggles.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 4\r\n\tUnique linkage, cost vector = (UNUSED=5 DIS=0 AND=0 LEN=0)\r\n\r\n[Visibility] [toggles] [.] \r\n\r\n", "e": "gram"}, {"i": [[497, 0, 35, 35, "Our"], [497, 0, 39, 39, "macros"], [497, 0, 46, 46, "support"], [497, 0, 54, 54, "conditional"], [497, 0, 66, 66, "expressions"], [497, 0, 79, 79, "which"], [497, 0, 85, 85, "enables"], [497, 0, 93, 93, "controlling"], [497, 0, 105, 105, "whether"], [497, 0, 113, 113, "to"], [497, 0, 116, 116, "render"], [497, 0, 123, 123, "an"], [497, 0, 126, 126, "object"]], "s": " Our macros support conditional expressions, which enables controllin \bg whether to render an object.\r\nNo complete linkages found.\r\nFound 2 linkages (1 had no P.P. violations) at null count 1\r\n\tUnique linkage, cost vector = (UNUSED=1 DIS=12 AND=0 LEN=25)\r\n\r\n    +---------------------------------------------------------------Xp----\r\n    +------------------------------Xx-----------------------------+       \r\n    |                +-----------------Op-----------------+       |       \r\n    |                |          +------------AN-----------+       |       \r\n    +-------Wi-------+          |           +------A------+       +-Ws+--S\r\n    |                |          |           |             |       |   |   \r\nLEFT-WALL [our] macros[?].v support.n conditional.a expressions.n , which \r\n\r\n\r\n----------------------------------------------------------+\r\n                                                          |\r\n                                                          |\r\n    +----------MVs---------+             +-----Os----+    |\r\ns*w-+-----Os----+          +--MVi-+---I--+     +--Ds-+    |\r\n    |           |          |      |      |     |     |    |\r\nenables.v controlling.g whether to.r render.v an object.n . \r\n\r\n", "e": "gram"}, {"i": [[497, 0, 134, 134, "For"], [497, 0, 138, 138, "example"], [497, 0, 147, 147, "a"], [497, 0, 149, 149, "boolean"], [497, 0, 157, 157, "input"], [497, 0, 163, 163, "attribute"], [497, 0, 173, 173, "can"], [497, 0, 177, 177, "control"], [497, 0, 185, 185, "whether"], [497, 0, 193, 193, "to"], [497, 0, 196, 196, "show"], [497, 0, 201, 201, "a"], [497, 0, 203, 203, "circle"]], "s": " For example, a boolean input attribute can control whether to show a \b circle:.\r\nNo complete linkages found.\r\nFound 4 linkages (4 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=9 AND=0 LEN=31)\r\n\r\n    +----------------------------------------------------Xp----------------\r\n    +-----------------------Wd----------------------+                      \r\n    |            +----------------CO----------------+                      \r\n    |            |      +-------------Ds------------+                +-----\r\n    |      +IDBXA+-Xc-+ |       +----AN---+----AN---+---Ss---+---I---+---MV\r\n    |      |     |    | |       |         |         |        |       |     \r\nLEFT-WALL for example , a boolean[?].n input.n attribute.n can.v control.v \r\n\r\n\r\n-----------------------------------+\r\n                                   |\r\n                                   |\r\n---------Osn--------------+        |\r\ns--+--MVi-+--I--+   +--Ds-+        |\r\n   |      |     |   |     |        |\r\nwhether to.r show.v a circle.n [:] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[497, 1, 14, 270, "Alternative"], [497, 1, 26, 282, "representations"]], "s": " Alternative representations.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 4\r\n\tUnique linkage, cost vector = (UNUSED=5 DIS=0 AND=0 LEN=0)\r\n\r\n[Alternative] [representations] [.] \r\n\r\n", "e": "gram"}, {"i": [[497, 1, 44, 300, "Conditional"], [497, 1, 56, 312, "expressions"], [497, 1, 68, 324, "also"], [497, 1, 73, 329, "enable"], [497, 1, 80, 336, "choosing"], [497, 1, 89, 345, "between"], [497, 1, 97, 353, "multiple"], [497, 1, 106, 362, "representations"], [497, 1, 123, 379, "not"], [497, 1, 127, 383, "just"], [497, 1, 132, 388, "on"], [497, 1, 135, 391, "off"], [497, 1, 139, 395, "visibility"]], "s": " Conditional expressions also enable choosing between multiple repres \bentations, not just on/off visibility:.\r\nNo complete linkages found.\r\nFound 72 linkages (72 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=4 AND=0 LEN=12)\r\n\r\n                  +-------Sp-------+--------MVp-------+-----------Jp--\r\n     +-----AN-----+         +---E--+----Os---+        |         +-----\r\n     |            |         |      |         |        |         |     \r\nConditional expressions.n also enable.v choosing.g between multiple.n \r\n\r\n\r\n        +-------------------MXp------------------+           \r\n--------+         +--------------Xd--------------+           \r\n-AN-----+         +EB+     +----A---+-----AN-----+----Xc----+\r\n        |         |  |     |        |            |          |\r\nrepresentations.n , not just.a on/off[?].n visibility.n [:] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsection{Non-Euclidean: Sunburst Diagram}\nVisualizations often require non-Euclidean layouts, such as the polar layout for the Sunburst diagram. Instead of propagating and computing over Euclidean values such as x and y coordinates as in       , the visualization can use some other.", "errors": [{"i": [509, 0, 27, 27, "Sunburst"], "s": ["Sunburnt", "Sun burst", "Sun-burst"], "e": "spell"}, {"i": [509, 1, 85, 130, "Sunburst"], "s": ["Sunburnt", "Sun burst", "Sun-burst"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "For example, in a sunburst diagram (Figure~\\ref{fig:renderings:sunburst}), a node should be rendered  far from the center of the chart if its level is high. In our implementation, each node transitively computes its  radius as a function of its parent's. Likewise, the center of visualization propagates from parent to child, with the root node representing the center:", "errors": [{"i": [512, 0, 18, 18, "sunburst"], "s": ["sunburnt", "sun burst", "sun-burst"], "e": "spell"}, {"i": [512, 0, 63, 63, "sunburst"], "s": ["sunburnt", "sun burst", "sun-burst"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "The full example is available in Appendix~\\ref{???}.", "errors": [], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsection{Charting: Line Graphs and Scatter Plots}\nWe specified several types of charts with attribute grammars. For example, Figure~\\ref{fig:renderings:parlab2} depicts an X/Y scatter plot and Figure~\\ref{fig:renderings:line} depicts a line graph. We represent every data point as a leaf node in the tree. Tree traversals will compute details such as the X and Y ranges of a data set, which facilitates features such as normalization and centering.", "errors": [{"i": [529, 1, 102, 155, "parlab"], "s": ["parlay", "par lab", "par-lab"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Time series charts led to two additional encoding tricks. First, multiple time series data should often be represented at the same time, such as for a server farm, the output of each server as the days pass. Figure~\\ref{fig:renderings:ge} depicts one such multiple time series chart. Our approach was to represent each line as an intermediate node:\n                                                                                                                                                                                ", "errors": [{"i": [532, 0, 235, 235, "ge"], "s": ["age", "be", "gb", "gee", "gel", "gem", "get", "GM", "go", "he", "me", "re", "we"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Second, we found the above (Section~\\ref{sec:rendering}) rendering features such as zooming, panning, and 3D representations to be important for visualizing big time series data.", "errors": [{"i": [546, 0, 41, 41, "sec"], "s": ["Dec", "sea", "sect", "see", "set", "sew", "sex", "sic", "spec"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsection{Animation and Interaction: Treemap}\nWe declaratively encoded various animation effects with attribute grammars. For example, the fisheye effect enlarges the size of an element the closer the mouse draws near to it. Our core pattern is to encode time varying values as such the mouse position as input attributes and rerun the layout solver when the inputs change.", "errors": [{"i": [548, 0, 39, 39, "Treemap"], "s": ["Tree map", "Tree-map"], "e": "spell"}, {"i": [548, 1, 93, 141, "fisheye"], "s": ["fish eye", "fish-eye"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Beyond human interaction, we also support reaction to time. For example, for the treemap shown in Figure~\\ref{fig:renderings:treemap}, users may change the data set shown. Instead of immediately showing the new data set, we introduce a              attribute that an animation increments over time from 0 up to 1. The treemap interpolates the layout position based on the time, which yields a smooth transition for each data point:\n                                                                                                                                                                                                                                                                     ", "errors": [{"i": [551, 0, 81, 81, "treemap"], "s": ["tree map", "tree-map"], "e": "spell"}, {"i": [551, 0, 125, 125, "treemap"], "s": ["tree map", "tree-map"], "e": "spell"}, {"i": [551, 0, 318, 318, "treemap"], "s": ["tree map", "tree-map"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Visualizations like the treemap require recompilation of most of the attributes for such animations, which can become a bottleneck and thus benefits from acceleration by our tool.", "errors": [{"i": [565, 0, 24, 24, "treemap"], "s": ["tree map", "tree-map"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsection{Grid-based: Tables}\nWe now examine one of our most difficult case studies: HTML~[[CITE]] and CSS table layout~[[CITE]]. Tables appear in  most rich document layout languages such as CSS and       , and are an instanced of \\emph{grid-based layout}, which is popular for representing layouts such as user interfaces and data tables. In conversations with commercial browser developers, we found that the proposed standards for the layout language features were reverse-engineered from earlier implementations. Furthermore, at the time of writing, two such competing standards were proposed, and with unclear notions of completeness or cases of distinction.", "errors": [{"i": [[567, 0, 12, 12, "Grid-based"], [567, 0, 24, 24, "Tables"]], "s": " Grid-based: Tables.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 5\r\n\tUnique linkage, cost vector = (UNUSED=6 DIS=0 AND=0 LEN=0)\r\n\r\n[Grid-based] [:] [Tables] [.] \r\n\r\n", "e": "gram"}, {"i": [[567, 1, 0, 32, "We"], [567, 1, 3, 35, "now"], [567, 1, 7, 39, "examine"], [567, 1, 15, 47, "one"], [567, 1, 19, 51, "of"], [567, 1, 22, 54, "our"], [567, 1, 26, 58, "most"], [567, 1, 31, 63, "difficult"], [567, 1, 41, 73, "case"], [567, 1, 46, 78, "studies"], [567, 1, 55, 87, "HTML"], [567, 1, 62, 94, "CITE"], [567, 1, 69, 101, "and"], [567, 1, 73, 105, "CSS"], [567, 1, 77, 109, "table"], [567, 1, 83, 115, "layout"], [567, 1, 92, 124, "CITE"]], "s": " We now examine one of our most difficult case studies: HTML~[[CITE]] \b and CSS table layout~[[CITE].\r\nNo complete linkages found.\r\nFound 6 linkages (6 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=0 AND=1 LEN=45)\r\n\r\n    +---------------------------------------------------------------Xp------\r\n    +----------------------------------Xx---------------------------------+ \r\n    |                             +----------------Jp---------------+     +-\r\n    |      +-----Sp----+          |  +--------------Dmc-------------+     | \r\n    +--Wd--+   +---E---+--Os--+-Mp+  |    +---EA--+----A----+---AN--+     | \r\n    |      |   |       |      |   |  |    |       |         |       |     | \r\nLEFT-WALL we now.r examine.v one of our most difficult.a case.n studies.n : \r\n\r\n\r\n---------------------------------------------------------+\r\n                                                         |\r\n-------------Wi--------------+                           |\r\n     +----------COa----------+                           |\r\n     +--Xc--+                +------Os-----+             |\r\n     |      |                |             |             |\r\nHTML~[[CITE ] []] and CSS table.v layout~[[CITE[?].n []] . \r\n\r\n\r\n    +---------------------------------------------------------------Xp------\r\n    +----------------------------------Xx---------------------------------+ \r\n    |                             +----------------Jp---------------+     | \r\n    |      +-----Sp----+          |  +--------------Dmc-------------+     +-\r\n    +--Wd--+   +---E---+--Os--+-Mp+  |    +---EA--+----A----+---AN--+     | \r\n    |      |   |       |      |   |  |    |       |         |       |     | \r\nLEFT-WALL we now.r examine.v one of our most difficult.a case.n studies.n : \r\n\r\n\r\n---------------------------------------------------------+\r\n                                                         |\r\n                                                         |\r\n-------------Wi--------------+                           |\r\n                       +-COa-+------Os-----+             |\r\n                       |     |             |             |\r\nHTML~[[CITE ] []] and CSS table.v layout~[[CITE[?].n []] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "We found that specifying tables involved \\emph{non-linear} reasoning about \\emph{dynamic DAGs}, which we achieved by using abstract data types and  using encoding hints to perform DAG scheduling by reusing our attribute grammar tree scheduler. More dynamic formalisms such as a higher-order attribute grammars~          provide flexible alternatives, but it is not clear how to use them to address the performance criteria of the subsequent chapters.", "errors": [{"i": [570, 0, 89, 89, "DAGs"], "s": ["Bags", "DA's", "Dabs", "Dads", "DAG", "Dais", "Dams", "Days", "Digs", "Dogs", "Drags", "Fags", "Gags", "Lags", "Nags", "Rags", "Sags", "Tags", "Wags", "Zags"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Several challenges emerged in our analysis of HTML tables:\n               \n      \\textbf{Dynamic data structure.} Layout constraints guide the mapping from a cell node to its location in the table. The computed result of attribute constraints therefore determines the underlying graph structure rather than being provided as part of the input. \n      \\textbf{Computing over a DAG rather than tree.} Each cell of a table has two parent nodes: its row and its column. Static attribute grammars are more typically designed for computations over trees, where each node has at most one parent. Reasoning about dependencies must support this new structure.\n      \\textbf{Non-linear constraints.} Static attribute grammars linearly bound the computation size in terms of the number of attribute instances. A more iterative process is instead used to compute dimensions for CSS's automatic table layout algorithm.  \n             ", "errors": [{"i": [572, 4, 215, 866, "CSS's"], "s": ["Ass's", "CS S's", "CS-S's"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Ultimately, we wrote table-specific code in the specification (see above) and the runtime, but no table-specific code in our scheduler nor code generator. For an example of logic in the specific, the specification constructs the grid data structure  by manipulating functional lists rather than just numbers. Likewise, to ensure a column's computations over its cells are scheduled after the grid is constructed, we included this dependency in the specification. ", "errors": [{"i": [[579, 0, 0, 0, "Ultimately"], [579, 0, 12, 12, "we"], [579, 0, 15, 15, "wrote"], [579, 0, 21, 21, "table-specific"], [579, 0, 36, 36, "code"], [579, 0, 41, 41, "in"], [579, 0, 44, 44, "the"], [579, 0, 48, 48, "specification"], [579, 0, 62, 62, "(see"], [579, 0, 67, 67, "above)"], [579, 0, 74, 74, "and"], [579, 0, 78, 78, "the"], [579, 0, 82, 82, "runtime"], [579, 0, 91, 91, "but"], [579, 0, 95, 95, "no"], [579, 0, 98, 98, "table-specific"], [579, 0, 113, 113, "code"], [579, 0, 118, 118, "in"], [579, 0, 121, 121, "our"], [579, 0, 125, 125, "scheduler"], [579, 0, 135, 135, "nor"], [579, 0, 139, 139, "code"], [579, 0, 144, 144, "generator"]], "s": " Ultimately, we wrote table-specific code in the specification (see a \bbove) and the runtime, but no table-specific code in our scheduler nor code gene \brator.\r\nNo complete linkages found.\r\nFound 124 linkages (94 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=3 AND=1 LEN=84)\r\n\r\n    +-----------------------------------------------------------------\r\n    |                          +--------------------------------------\r\n    |                          +--------------------------------------\r\n    +----------Wd---------+    +---------------MVp--------------+     \r\n    |           +----CO---+    +-------------Os------------+    +-----\r\n    |           +--Xc--+  +-Sp-+             +------A------+    |  +--\r\n    |           |      |  |    |             |             |    |  |  \r\nLEFT-WALL ultimately.e , we wrote.v table-specific[!].a code.n in the \r\n\r\n\r\n----------------------------------------Xp--------------------------------\r\n-------------------------------MVp----------------------------------------\r\n--------MVp----------------------------------------------+                \r\n                                                         +----------------\r\nJp-----+-------MXsx-------+                              |          +-----\r\n-D*u---+        +----Xd---+-Xc+                          |          |     \r\n       |        |         |   |                          |          |     \r\nspecification.n ( [see] above ) and the runtime.a , but.misc-ex no.misc-d \r\n\r\n\r\n------------------------------------------------------------------------+\r\n----------------------------+                                           |\r\n                            |                                           |\r\n---Jp------------------+    +-----------------Js-----------------+      |\r\n--------D*u------------+    |  +----------------Ds---------------+      |\r\n         +------A------+    |  |         +-----------AN----------+      |\r\n         |             |    |  |         |                       |      |\r\ntable-specific[!].a code.n in our scheduler[?].n nor code.n generator.n . \r\n\r\n\r\n    +-----------------------------------------------------------------\r\n    |                          +--------------------------------------\r\n    |                          +--------------------------------------\r\n    +----------Wd---------+    +---------------MVp--------------+     \r\n    |           +----CO---+    +-------------Os------------+    +-----\r\n    |           +--Xc--+  +-Sp-+             +------A------+    |  +--\r\n    |           |      |  |    |             |             |    |  |  \r\nLEFT-WALL ultimately.e , we wrote.v table-specific[!].a code.n in the \r\n\r\n\r\n----------------------------------------Xp--------------------------------\r\n-------------------------------MVp----------------------------------------\r\n--------MVp----------------------------------------------+                \r\n                                                         +----------------\r\nJp-----+-------MXsx-------+                              |          +-----\r\n-D*u---+        +----Xd---+-Xc+                          |          |     \r\n       |        |         |   |                          |          |     \r\nspecification.n ( [see] above ) and the runtime.a , but.misc-ex no.misc-d \r\n\r\n\r\n------------------------------------------------------------------------+\r\n----------------------------+                                           |\r\n                            |                                           |\r\n---Jp------------------+    +-----------------Js-----------------+      |\r\n--------D*u------------+    |  +----------------Ds---------------+      |\r\n         +------A------+    |  |                        +---AN---+      |\r\n         |             |    |  |                        |        |      |\r\ntable-specific[!].a code.n in our scheduler[?].n nor code.n generator.n . \r\n\r\n\r\n    +-----------------------------------------------------------------\r\n    |                          +--------------------------------------\r\n    |                          +--------------------------------------\r\n    +----------Wd---------+    +---------------MVp--------------+     \r\n    |           +----CO---+    +-------------Os------------+    +-----\r\n    |           +--Xc--+  +-Sp-+             +------A------+    |  +--\r\n    |           |      |  |    |             |             |    |  |  \r\nLEFT-WALL ultimately.e , we wrote.v table-specific[!].a code.n in the \r\n\r\n\r\n----------------------------------------Xp--------------------------------\r\n-------------------------------MVp----------------------------------------\r\n--------MVp----------------------------------------------+                \r\n       +-----------------MXs----------------+            +----------------\r\nJp-----+        +-------------Xd------------+            |          +-----\r\n-D*u---+        |                    +--DD--+--Xc-+      |          |     \r\n       |        |                    |      |     |      |          |     \r\nspecification.n ( [see] above ) and the runtime.a , but.misc-ex no.misc-d \r\n\r\n\r\n------------------------------------------------------------------------+\r\n----------------------------+                                           |\r\n                            |                                           |\r\n---Jp------------------+    +-----------------Js-----------------+      |\r\n--------D*u------------+    |  +----------------Ds---------------+      |\r\n         +------A------+    |  |         +-----------AN----------+      |\r\n         |             |    |  |         |                       |      |\r\ntable-specific[!].a code.n in our scheduler[?].n nor code.n generator.n . \r\n\r\n\r\n    +-----------------------------------------------------------------\r\n    |                          +--------------------------------------\r\n    |                          +--------------------------------------\r\n    +----------Wd---------+    +---------------MVp--------------+     \r\n    |           +----CO---+    +-------------Os------------+    +-----\r\n    |           +--Xc--+  +-Sp-+             +------A------+    |  +--\r\n    |           |      |  |    |             |             |    |  |  \r\nLEFT-WALL ultimately.e , we wrote.v table-specific[!].a code.n in the \r\n\r\n\r\n----------------------------------------Xp--------------------------------\r\n-------------------------------MVp----------------------------------------\r\n--------MVp----------------------------------------------+                \r\n       +-----------------MXs----------------+            +----------------\r\nJp-----+        +-------------Xd------------+            |          +-----\r\n-D*u---+        |                    +--DD--+--Xc-+      |          |     \r\n       |        |                    |      |     |      |          |     \r\nspecification.n ( [see] above ) and the runtime.a , but.misc-ex no.misc-d \r\n\r\n\r\n------------------------------------------------------------------------+\r\n----------------------------+                                           |\r\n                            |                                           |\r\n---Jp------------------+    +-----------------Js-----------------+      |\r\n--------D*u------------+    |  +----------------Ds---------------+      |\r\n         +------A------+    |  |                        +---AN---+      |\r\n         |             |    |  |                        |        |      |\r\ntable-specific[!].a code.n in our scheduler[?].n nor code.n generator.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Our runtime edits were to use a breadth-first traversal for traversing a table and, to lookup the children of a column, search table rows for cells with the corresponding column number attribute. We did not have to add table-specific code into the synthesizer (the offline scheduling analysis) nor the code generator. ", "errors": [], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "We address each problem in turn.", "errors": [], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "              \n                                                                         \n                                           \n\\includegraphics[trim=0 0 0 0,clip,width=1.0\\columnwidth]{chapter2/tabletransitive}\n              }\n                                                                                    \n                                           \n                            \n              \n}\n\\caption{\\textbf{Document layout screenshots.}}\n                         \n            ", "errors": [{"i": [621, 10, 33, 441, "screenshots"], "s": ["screen shots", "screen-shots"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsubsection{Dynamic data structure.}\nFigure~\\ref{fig:docrenderings} illustrates why the mapping from table cells to table column is dynamically computed. The placement of a cell is complicated by preceding cells that span multiple rows (\"rowspan=n\") and columns (\"colspan=n\"). Ultimately, the cell must be placed in the first column such that an earlier cell in a top-down, left-to-right ordering does not overlap it. The figure shows two important cases. First, the second cell of the first row is placed in the third column because its left sibling spans two rows: a cell's column is a function of the                attributes of its siblings to the left.  The second case is shown for the bottom right cell. Even though it is the third cell of its row in the parse tree, it is not placed in the third column. The reason is that the red dashed rectangular cell in the second row transitively impacts the placement of the cells after it. The                attributes of cells in rows above a cell further determine its column.", "errors": [{"i": [635, 1, 16, 56, "docrenderings"], "s": ["Doc renderings", "Doc-renderings"], "e": "spell"}, {"i": [635, 1, 201, 241, "rowspan"], "s": ["rows pan", "rows-pan", "row span", "row-span"], "e": "spell"}, {"i": [635, 1, 227, 267, "colspan"], "s": [], "e": "spell"}, {"i": [635, 1, 337, 377, "left-to-right"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Our specification computes the column assignment as a loop over the rows. For each row, it computes what columns its cells are placed in as a function of the list of columns that are still occupied by preceding cells. The next row is given the columns that are occupied after adding cells on the current row, etc. Our specification of this behavior is interesting in that it is just calls to functional list manipulation methods written in our host language:\n                                                                                                                                                                                                                                                              ", "errors": [{"i": [[638, 0, 0, 0, "Our"], [638, 0, 4, 4, "specification"], [638, 0, 18, 18, "computes"], [638, 0, 27, 27, "the"], [638, 0, 31, 31, "column"], [638, 0, 38, 38, "assignment"], [638, 0, 49, 49, "as"], [638, 0, 52, 52, "a"], [638, 0, 54, 54, "loop"], [638, 0, 59, 59, "over"], [638, 0, 64, 64, "the"], [638, 0, 68, 68, "rows"]], "s": " Our specification computes the column assignment as a loop over the  \brows.\r\nNo complete linkages found.\r\nFound 2 linkages (2 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=2 AND=0 LEN=22)\r\n\r\n    +----------------------------------------------Xp-----------------------\r\n    |                              +---------------MVp---------------+      \r\n    |                              +-----------Os-----------+        |      \r\n    +-------Wd-------+             |      +--------Ds-------+        |      \r\n    |      +---D*u---+------Ss-----+      |      +----AN----+        +------\r\n    |      |         |             |      |      |          |        |      \r\nLEFT-WALL our specification.n computes.v the column.n assignment.n as.p [a] \r\n\r\n\r\n-----------------------+\r\n                       |\r\n                       |\r\n         +----Jp---+   |\r\n-Mp------+   +-Dmc-+   |\r\n         |   |     |   |\r\n[loop] over the rows.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[638, 0, 74, 74, "For"], [638, 0, 78, 78, "each"], [638, 0, 83, 83, "row"], [638, 0, 88, 88, "it"], [638, 0, 91, 91, "computes"], [638, 0, 100, 100, "what"], [638, 0, 105, 105, "columns"], [638, 0, 113, 113, "its"], [638, 0, 117, 117, "cells"], [638, 0, 123, 123, "are"], [638, 0, 127, 127, "placed"], [638, 0, 134, 134, "in"], [638, 0, 137, 137, "as"], [638, 0, 140, 140, "a"], [638, 0, 142, 142, "function"], [638, 0, 151, 151, "of"], [638, 0, 154, 154, "the"], [638, 0, 158, 158, "list"], [638, 0, 163, 163, "of"], [638, 0, 166, 166, "columns"], [638, 0, 174, 174, "that"], [638, 0, 179, 179, "are"], [638, 0, 183, 183, "still"], [638, 0, 189, 189, "occupied"], [638, 0, 198, 198, "by"], [638, 0, 201, 201, "preceding"], [638, 0, 211, 211, "cells"]], "s": " For each row, it computes what columns its cells are placed in as a  \bfunction of the list of columns that are still occupied by preceding cells.\r\nNo complete linkages found.\r\nFound 21474 linkages (274 of 1000 random linkages had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=5 AND=0 LEN=65)\r\n\r\n    +-------------------------------------------------------------------------\r\n    +------------Wd-----------+                                               \r\n    |       +--------CO-------+      +--------------------------MVp-----------\r\n    |       +------Xc------+  |      |                +----------------Bp-----\r\n    |       +----Js----+   |  |      |                +-----Rn-----+          \r\n    |       |     +-Ds-+   |  +--Ss--+-------Op-------+      +-Dmc-+--Spx-+---\r\n    |       |     |    |   |  |      |                |      |     |      |   \r\nLEFT-WALL for.p each row.n , it computes.v [what] columns.n its cells.n are.v \r\n\r\n\r\n---------------------Xp----------------------------------------------------\r\n--------------+         +-------------------------------Mv-----------------\r\n----------+   |         +---------Mp---------+                             \r\n          |   +----Js---+      +---Js---+    |     +---------Bp--------+   \r\nPv--+-MVp-+   |  +--Ds--+--Mp--+  +--Ds-+    +--Jp-+-----R----+---RS---+--P\r\n    |     |   |  |      |      |  |     |    |     |          |        |   \r\nplaced.v in as.p a function.n of the list.n of columns.n that.misc-r are.v \r\n\r\n\r\n------------------------------------------+\r\n                                          |\r\n-------------+                            |\r\n             |                            |\r\n             |                            |\r\na--+         +--MVp-+--Mgp-+----Op---+    |\r\n   |         |      |      |         |    |\r\nstill.a occupied.v by preceding.v cells.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[638, 0, 314, 314, "Our"], [638, 0, 318, 318, "specification"], [638, 0, 332, 332, "of"], [638, 0, 335, 335, "this"], [638, 0, 340, 340, "behavior"], [638, 0, 349, 349, "is"], [638, 0, 352, 352, "interesting"], [638, 0, 364, 364, "in"], [638, 0, 367, 367, "that"], [638, 0, 372, 372, "it"], [638, 0, 375, 375, "is"], [638, 0, 378, 378, "just"], [638, 0, 383, 383, "calls"], [638, 0, 389, 389, "to"], [638, 0, 392, 392, "functional"], [638, 0, 403, 403, "list"], [638, 0, 408, 408, "manipulation"], [638, 0, 421, 421, "methods"], [638, 0, 429, 429, "written"], [638, 0, 437, 437, "in"], [638, 0, 440, 440, "our"], [638, 0, 444, 444, "host"], [638, 0, 449, 449, "language"]], "s": " Our specification of this behavior is interesting in that it is just \b calls to functional list manipulation methods written in our host language:.\r\nNo complete linkages found.\r\nFound 11292 linkages (75 of 1000 random linkages had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=0 AND=0 LEN=40)\r\n\r\n    +-------------------------------------------------------------------------\r\n    |                +---------------Ss--------------+                        \r\n    +-------Wd-------+         +------Jp-----+       |        +-----MVs----+  \r\n    |      +---D*u---+----Mp---+    +---D*u--+       +---Paf--+        +IDB+-C\r\n    |      |         |         |    |        |       |        |        |   |  \r\nLEFT-WALL our specification.n of this.d behavior.n is.v interesting.a in that \r\n\r\n\r\n-------------------Xp----------------------------------------------------\r\n     +--------MVp--------+--------------------Jp-------------------+     \r\n     +-----Opt----+      |        +----------A---------+           |     \r\ns+-Ss+-EBm-+      |      |        |         +----AN----+-----AN----+----M\r\n |   |     |      |      |        |         |          |           |     \r\nit is.v just.e calls.n to.r functional.a list.n manipulation.n methods.n \r\n\r\n\r\n---------------------------------------+\r\n           +--------Jp-------+         |\r\n           |  +------D*u-----+         |\r\nv---+--MVp-+  |     +---AN---+         |\r\n    |      |  |     |        |         |\r\nwritten.v in our host.n language.n [:] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "The                         function computes the column position during placement, so subsequent reads can look it up through another list manipulation function.", "errors": [{"i": [[652, 0, 0, 0, "The"], [652, 0, 28, 28, "function"], [652, 0, 37, 37, "computes"], [652, 0, 46, 46, "the"], [652, 0, 50, 50, "column"], [652, 0, 57, 57, "position"], [652, 0, 66, 66, "during"], [652, 0, 73, 73, "placement"], [652, 0, 84, 84, "so"], [652, 0, 87, 87, "subsequent"], [652, 0, 98, 98, "reads"], [652, 0, 104, 104, "can"], [652, 0, 108, 108, "look"], [652, 0, 113, 113, "it"], [652, 0, 116, 116, "up"], [652, 0, 119, 119, "through"], [652, 0, 127, 127, "another"], [652, 0, 135, 135, "list"], [652, 0, 140, 140, "manipulation"], [652, 0, 153, 153, "function"]], "s": " The                         function computes the column position du \bring placement, so subsequent reads can look it up through another list manipula \btion function.\r\nNo complete linkages found.\r\nFound 496 linkages (38 had no P.P. violations) at null count 4\r\n\tLinkage 1, cost vector = (UNUSED=4 DIS=2 AND=0 LEN=46)\r\n\r\n    +--------------------------------------------------------------\r\n    |              +------------------------------CC---------------\r\n    |              |          +---------------MVp--------------+   \r\n    |              |          +-----------Os----------+        |   \r\n    +------Wd------+          |      +-------Ds-------+        |   \r\n    |      +---Ds--+----Ss----+      |      +----AN---+        +---\r\n    |      |       |          |      |      |         |        |   \r\nLEFT-WALL the function.n computes.v the column.n position.n during \r\n\r\n\r\n-----------------------Xp----------------------------------------------------\r\n---------------+                                                             \r\n               |                                                             \r\n               |                                        +--------------------\r\n               |                        +-------I-------+               +----\r\nJp---+      +Xd+-----------Qd-----------+----SIs----+   |               |    \r\n     |      |  |                        |           |   |               |    \r\nplacement.n , so [subsequent] [reads] can.v [look] it up.v [through] another \r\n\r\n\r\n---------------------------------+\r\n                                 |\r\n                                 |\r\n---Os----------------------+     |\r\n-----------Ds--------------+     |\r\n   +----AN----+-----AN-----+     |\r\n   |          |            |     |\r\nlist.n manipulation.n function.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "              \n                                                                           \n                                           \n                   \n              }\n                                                                    \n                                           \n                   \n              }\n\\caption{\\textbf{Specifying dynamic dependencies.}}\n                       \n            ", "errors": [{"i": [[677, 9, 17, 337, "Specifying"], [677, 9, 28, 348, "dynamic"], [677, 9, 36, 356, "dependencies"]], "s": " Specifying dynamic dependencies.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 5\r\n\tUnique linkage, cost vector = (UNUSED=6 DIS=0 AND=0 LEN=0)\r\n\r\n[specifying] [dynamic] [dependencies] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "A column computes the x coordinates for each cell, but column cells are not known before the last                        () call. To ensure a column computes over its cells after the mapping occurs, we explicitly declare the dynamic data dependency in the specification. First, the grid is stored in an attribute, so we simply propagate the grid to all the table nodes as an attribute (                 ). We then state the implicit data dependency (Figure~\\ref{fig:tabledyndep}. The scheduler now knows to run column computations over cells only after the                   is computed. Currently, we directly specify the constraints by enabling low-level schedule constraints (Figure~\\ref{fig:tabledyndep:raw} and Section~[[[???]]), which might be directly generated from surface syntax (Figure~\\ref{fig:tabledyndep:clean}).", "errors": [{"i": [690, 0, 462, 462, "fig"], "s": [], "e": "spell"}, {"i": [690, 0, 638, 638, "enabling"], "s": ["low level", "low-level"], "e": "spell"}, {"i": [690, 0, 691, 691, "fig"], "s": [], "e": "spell"}, {"i": [690, 0, 802, 802, "fig"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsubsection{Computing over a DAG}\nComputing over a table means computing over a DAG, not a tree: a cell has both a row and a column as its parents. This impacted both our runtime and our specification strategy. Demonstrating the flexibility of attribute grammars, we did not have to modify the scheduler nor the code generator. Instead, we modified the runtime and the specification.", "errors": [{"i": [[692, 0, 15, 15, "Computing"], [692, 0, 25, 25, "over"], [692, 0, 30, 30, "a"], [692, 0, 32, 32, "DAG"]], "s": " Computing over a DAG.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 6\r\n\tUnique linkage, cost vector = (UNUSED=7 DIS=0 AND=0 LEN=0)\r\n\r\n[computing] [over] [a] [DAG] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "We modified the runtime to generalize an important invariant from tree traversals to DAG traversals. In a top down traversal of a tree, a node's parent is visited before the node itself. A valid implementation for trees is depth first. However, consider a depth first traversal of a table's parse tree:\n                                                                                                    ", "errors": [{"i": [[695, 0, 101, 101, "In"], [695, 0, 104, 104, "a"], [695, 0, 106, 106, "top"], [695, 0, 110, 110, "down"], [695, 0, 115, 115, "traversal"], [695, 0, 125, 125, "of"], [695, 0, 128, 128, "a"], [695, 0, 130, 130, "tree"], [695, 0, 136, 136, "a"], [695, 0, 138, 138, "node's"], [695, 0, 145, 145, "parent"], [695, 0, 152, 152, "is"], [695, 0, 155, 155, "visited"], [695, 0, 163, 163, "before"], [695, 0, 170, 170, "the"], [695, 0, 174, 174, "node"], [695, 0, 179, 179, "itself"]], "s": " In a top down traversal of a tree, a node's parent is visited before \b the node itself.\r\nNo complete linkages found.\r\nFound 26 linkages (3 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=5 AND=0 LEN=57)\r\n\r\n    +-------------------------------------------------------Xp---------------\r\n    +---------------------------------Wd--------------------------------+    \r\n    |      +-----------------------------CO-----------------------------+    \r\n    |      +-------------------Xc-------------------+                   |    \r\n    |      +--Js-+                       +--Js--+   |                   |    \r\n    |      | +-Ds+-----------Mp----------+ +-Ds-+   | +-Ds-+--YS-+--Ds--+--Ss\r\n    |      | |   |                       | |    |   | |    |     |      |    \r\nLEFT-WALL in a top.n [down] [traversal] of a tree.n , a node.n 's.p parent.n \r\n\r\n\r\n----------------------------------------+\r\n                                        |\r\n                                        |\r\n         +------------MVa-----------+   |\r\n         |        +----Js----+      |   |\r\n--+--Pv--+---MVp--+    +--Ds-+      |   |\r\n  |      |        |    |     |      |   |\r\nis.v visited.v before the node.n itself . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[695, 0, 236, 236, "However"], [695, 0, 245, 245, "consider"], [695, 0, 254, 254, "a"], [695, 0, 256, 256, "depth"], [695, 0, 262, 262, "first"], [695, 0, 268, 268, "traversal"], [695, 0, 278, 278, "of"], [695, 0, 281, 281, "a"], [695, 0, 283, 283, "table's"], [695, 0, 291, 291, "parse"], [695, 0, 297, 297, "tree"]], "s": " However, consider a depth first traversal of a table's parse tree:.\r\nNo complete linkages found.\r\nFound 12 linkages (1 had no P.P. violations) at null count 2\r\n\tUnique linkage, cost vector = (UNUSED=2 DIS=2 AND=0 LEN=26)\r\n\r\n    +-----------------------------------------------Xp----------------------\r\n    +----------Wi----------+--------Os--------+                 +-----------\r\n    |         +-----CO-----+     +-----Ds-----+                 |           \r\n    |         +--Xc-+      |     |    +---AN--+--------Mp-------+ +-Ds-+--YS\r\n    |         |     |      |     |    |       |                 | |    |    \r\nLEFT-WALL however.e , consider.v a depth.n first.n [traversal] of a table.n \r\n\r\n\r\n------------------------+\r\n--Js------------+       |\r\n  +------Ds-----+       |\r\n--+     +---AN--+       |\r\n  |     |       |       |\r\n's.p parse.n tree.n [:] . \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "The depth-first traversal would visit the table, the row, the cell, and then the column. The cell is visited before its parent column! ", "errors": [{"i": [[704, 0, 0, 0, "The"], [704, 0, 4, 4, "depth-first"], [704, 0, 16, 16, "traversal"], [704, 0, 26, 26, "would"], [704, 0, 32, 32, "visit"], [704, 0, 38, 38, "the"], [704, 0, 42, 42, "table"], [704, 0, 49, 49, "the"], [704, 0, 53, 53, "row"], [704, 0, 58, 58, "the"], [704, 0, 62, 62, "cell"], [704, 0, 68, 68, "and"], [704, 0, 72, 72, "then"], [704, 0, 77, 77, "the"], [704, 0, 81, 81, "column"]], "s": " The depth-first traversal would visit the table, the row, the cell,  \band then the column.\r\nNo complete linkages found.\r\nFound 158 linkages (52 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=6 AND=0 LEN=22)\r\n\r\n                                                        +-----------MXs----\r\n                                                        +-----MXs----+     \r\n                                            +-----Os----+    +---Xd--+   +-\r\n +-----D----+-----------S-----------+---I---+     +--Ds-+    |  +-Ds-+Xca+ \r\n |          |                       |       |     |     |    |  |    |   | \r\nthe depth-first[!].n [traversal] would.v visit.v the table.n , the row.n , \r\n\r\n\r\n-------+                              \r\n       |                              \r\n--Xd---+                              \r\n +--Ds-+--------------Xc-------------+\r\n |     |                             |\r\nthe cell.n , and [then] the column.n . \r\n\r\n\r\n                                                        +------------------\r\n                                                        +-----MXs----+     \r\n                                            +-----Os----+    +---Xd--+   +-\r\n +-----D----+-----------S-----------+---I---+     +--Ds-+    |  +-Ds-+Xca+ \r\n |          |                       |       |     |     |    |  |    |   | \r\nthe depth-first[!].n [traversal] would.v visit.v the table.n , the row.n , \r\n\r\n\r\n------MXs-----------------------+     \r\n                                |     \r\n---------------Xd---------------+     \r\n                         +--Ds--+-Xc-+\r\n                         |      |    |\r\nthe cell.n , and [then] the column.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[704, 0, 89, 89, "The"], [704, 0, 93, 93, "cell"], [704, 0, 98, 98, "is"], [704, 0, 101, 101, "visited"], [704, 0, 109, 109, "before"], [704, 0, 116, 116, "its"], [704, 0, 120, 120, "parent"], [704, 0, 127, 127, "column"]], "s": " The cell is visited before its parent column!.\r\nNo complete linkages found.\r\nFound 2 linkages (2 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=2 AND=0 LEN=13)\r\n\r\n    +-----------------------------Xp-----------------------------+   \r\n    |                                  +---------Js---------+    |   \r\n    +-----Wd-----+                     |    +-------Ds------+    |   \r\n    |      +--Ds-+--Ss-+--Pv--+---MVp--+    |      +---AN---+    |   \r\n    |      |     |     |      |        |    |      |        |    |   \r\nLEFT-WALL the cell.n is.v visited.v before its parent.n column.n ! [.] \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Our modification was simple: we edited the runtime to visit the nodes of a table with a breadth first traversal. We kept the overall document traversal as depth first for performance reasons. Declarative schedule constraints would also support picking a breadth-first traversal (Section~\\ref{???}).", "errors": [{"i": [[706, 0, 192, 192, "Declarative"], [706, 0, 204, 204, "schedule"], [706, 0, 213, 213, "constraints"], [706, 0, 225, 225, "would"], [706, 0, 231, 231, "also"], [706, 0, 236, 236, "support"], [706, 0, 244, 244, "picking"], [706, 0, 252, 252, "a"], [706, 0, 254, 254, "breadth-first"], [706, 0, 268, 268, "traversal"], [706, 0, 278, 278, "(Section"]], "s": " Declarative schedule constraints would also support picking a breadt \bh-first traversal (Section~.\r\nNo complete linkages found.\r\nFound 132 linkages (45 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=2 AND=0 LEN=7)\r\n\r\n                                          +------I------+-------------O---\r\n      +------A-----+-----AN----+----Sp----+      +---E--+               +-\r\n      |            |           |          |      |      |               | \r\ndeclarative.a schedule.n constraints.n would.v also support.v [picking] a \r\n\r\n\r\n---------+-------------MX------------+     \r\n---Ds----+                     +--Xd-+-Xc-+\r\n         |                     |     |    |\r\nbreadth-first[!].n [traversal] ( Section~ . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[706, 0, 296, 296, ")"]], "s": " ).\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 3\r\n\tUnique linkage, cost vector = (UNUSED=4 DIS=0 AND=0 LEN=0)\r\n\r\n[)] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "We also modified the specification to pass our attribute grammar static checker. The changes enables relaxing the scheduler's obligation to guarantee that visiting a cell's parent row and column would set all the attributes needed by the cell (unambiguous) and without conflicting with each other. For example, a column defines the             attribute of its child cell, and a row, its            . By default, our checker would rightfully reject such a specification because, if a cell has only one parent, only one of those attributes would be set.", "errors": [{"i": [[708, 0, 298, 298, "For"], [708, 0, 302, 302, "example"], [708, 0, 311, 311, "a"], [708, 0, 313, 313, "column"], [708, 0, 320, 320, "defines"], [708, 0, 328, 328, "the"], [708, 0, 344, 344, "attribute"], [708, 0, 354, 354, "of"], [708, 0, 357, 357, "its"], [708, 0, 361, 361, "child"], [708, 0, 367, 367, "cell"], [708, 0, 373, 373, "and"], [708, 0, 377, 377, "a"], [708, 0, 379, 379, "row"], [708, 0, 384, 384, "its"]], "s": " For example, a column defines the             attribute of its child \b cell, and a row, its .\r\nNo complete linkages found.\r\nFound 4 linkages (4 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=4 AND=0 LEN=33)\r\n\r\n    +--------------------------------------------------Xp-------------------\r\n    +------------Wd-----------+                               +-------Js----\r\n    |            +-----CO-----+        +------Os------+       |  +------Ds--\r\n    |      +IDBXA+-Xc-+ +--Ds-+---Ss---+      +---Ds--+---Mp--+  |     +---A\r\n    |      |     |    | |     |        |      |       |       |  |     |    \r\nLEFT-WALL for example , a column.n defines.v the attribute.n of its child.n \r\n\r\n\r\n-------------------------------+\r\n---+------MXs------+           |\r\n---+   +-----Xd----+           |\r\nN--+   |       +-Ds+-Xc+       |\r\n   |   |       |   |   |       |\r\ncell.n , [and] a row.n , [its] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "We extended the specification language for instructing the scheduler that external code defines certain attributes:\n                                                                                                                                                                  ", "errors": [{"i": [[710, 0, 0, 0, "We"], [710, 0, 3, 3, "extended"], [710, 0, 12, 12, "the"], [710, 0, 16, 16, "specification"], [710, 0, 30, 30, "language"], [710, 0, 39, 39, "for"], [710, 0, 43, 43, "instructing"], [710, 0, 55, 55, "the"], [710, 0, 59, 59, "scheduler"], [710, 0, 69, 69, "that"], [710, 0, 74, 74, "external"], [710, 0, 83, 83, "code"], [710, 0, 88, 88, "defines"], [710, 0, 96, 96, "certain"], [710, 0, 104, 104, "attributes"]], "s": " We extended the specification language for instructing the scheduler \b that external code defines certain attributes:.\r\nNo complete linkages found.\r\nFound 14 linkages (2 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=2 AND=0 LEN=38)\r\n\r\n    +----------------------------------------------------------------------\r\n    |                                                              +-------\r\n    |      +----------------------CC---------------------+         +-------\r\n    |      |      +--------------Os--------------+       |         |       \r\n    |      |      |      +----------D*u----------+       |         |       \r\n    +--Wd--+--Sp--+      |         +------AN-----+       +----Wd---+       \r\n    |      |      |      |         |             |       |         |       \r\nLEFT-WALL we extended.v the specification.n language.n for.r instructing.g \r\n\r\n\r\n-------Xp------------------------------------------------------------\r\n---------------------Ss*g----------------------------+               \r\n------------------Os-------------------------+       |               \r\n +--------------------D*u--------------------+       |               \r\n |         +----------------A----------------+       +----------Op---\r\n |         |            +-----EA----+----A---+       |         +-----\r\n |         |            |           |        |       |         |     \r\nthe scheduler[?].a that.misc-r external.a code.n defines.v certain.a \r\n\r\n\r\n-----------------+\r\n                 |\r\n                 |\r\n                 |\r\n------+          |\r\nA-----+          |\r\n      |          |\r\nattributes.n [:] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "The scheduler now assumes that the external code provides definitions for a column's                    and                    and a row's                    and                   . Unimportant to the synthesizer, the definitions just happen to come from elsewhere in the same specification, such as class Row defining the phantom attributes not set by Column. %If we wanted to further verify our specification, we could further specify that the assignments of a row and a column to a cell are disjoint sets that, together, hold the assignments needed for a cell, but this is unnecessary for code generation. ", "errors": [{"i": [723, 0, 133, 133, "row's"], "s": ["brow's", "how's", "prow's", "Rob's", "rod's", "Ron's", "rows", "Roy's", "sow's"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsubsection{Non-linear constraints}\nThe table specification defines a dynamically determined number of loops over a table's column to determine column widths. Such dynamism is beyond the pure static attribute grammar formalism, but our foreign function interface sufficed while still allowing overall specification and scheduling through attribute grammars.", "errors": [{"i": [[725, 0, 15, 15, "Non-linear"], [725, 0, 26, 26, "constraints"]], "s": " Non-linear constraints.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 4\r\n\tUnique linkage, cost vector = (UNUSED=5 DIS=0 AND=0 LEN=0)\r\n\r\n[Non-linear] [constraints] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\subsection{Flow-based: CSS Box Model}\nDocument layout languages generally feature a \\emph{flow-based} layout model where the position of one element is largely a function of the previous one. For example, line wrapping places one word after another in a paragraph, and a column will stack one paragraph after another. However, ambiguity quickly arises once constraints are added to such systems. We found that, before being able to address our interest in parallelizing the CSS language, that creating a functional specification of it was already a challenge to itself.  This section focuses on the ability to express the CSS specification, and defers discussion of functional correctness (Chapter~??) and safe parallelization (Chapter~??).", "errors": [{"i": [[728, 0, 12, 12, "Flow-based"], [728, 0, 24, 24, "CSS"], [728, 0, 28, 28, "Box"], [728, 0, 32, 32, "Model"]], "s": " Flow-based: CSS Box Model.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 7\r\n\tUnique linkage, cost vector = (UNUSED=8 DIS=0 AND=0 LEN=0)\r\n\r\n[Flow-based] [:] [CSS] [Box] [Model] [.] \r\n\r\n", "e": "gram"}, {"i": [[728, 1, 662, 701, ")"], [728, 1, 664, 703, "and"], [728, 1, 668, 707, "safe"], [728, 1, 673, 712, "parallelization"], [728, 1, 689, 728, "(Chapter"]], "s": " ) and safe parallelization (Chapter~.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 8\r\n\tUnique linkage, cost vector = (UNUSED=9 DIS=0 AND=0 LEN=0)\r\n\r\n[)] [and] [safe] [parallelization] [(] [Chapter~] [.] \r\n\r\n", "e": "gram"}, {"i": [[728, 1, 700, 739, ")"]], "s": " ).\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 3\r\n\tUnique linkage, cost vector = (UNUSED=4 DIS=0 AND=0 LEN=0)\r\n\r\n[)] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Challenging specification, the CSS standard provides only a few explicit formulas such as                                                             for the shrink-to-fit calculation. It generally does not fully define the intrinsic dimensions to plug into the formula. We incorporated what we found, and for the rest, spent significant time reengineering the semantics by examining the standard and experimenting with existing browsers. While it is unclear how to evaluate faithfulness, we encoded enough features to render a resemblance of the Wikipedia main page (Figure~\\ref{fig:rendering:css}) and a popular blog.", "errors": [{"i": [731, 0, 158, 158, "shrink-to-fit"], "s": [], "e": "spell"}, {"i": [731, 0, 343, 343, "reengineering"], "s": ["re engineering", "re-engineering"], "e": "spell"}, {"i": [731, 0, 547, 547, "Wikipedia"], "s": [], "e": "spell"}, {"i": [731, 0, 594, 594, "css"], "s": ["ass", "CS", "CSS", "CST", "cuss", "CVS"], "e": "spell"}, {"i": [731, 0, 614, 614, "blog"], "s": ["bldg", "blob", "bloc", "blot", "blow", "bog", "clog", "flog", "log", "slog"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Our attribute grammar describes the layout solving features of the informally written CSS 2.1 standard. It also includes automatic table layout, which was only more completely defined in later CSS standards. It does not include preprocessing steps, such as the CSS cascade that annotates the HTML tree with attributes, nor anonymous content generation, which normalizes the annotated tree to guarantee that spans of sibling nodes are homogeneous. The former is largely a combination of a simple extension to regular expressions and prioritization constraints. We found we could include parts of the cascade in our approach, such as handling units, and thus do.  Normalization is a bottom-up tree rewriting pass, and an implementation optimization avoids performing it before layout and instead makes it an on-demand part of layout solving. We primarily focus in the core box model: normal flow (blocks and inlines), out of flow (relative and absolute positioning, floats), and borders, padding, and margins.", "errors": [{"i": [733, 0, 906, 906, "inlines)"], "s": ["inclines", "in lines", "in-lines"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Our specification largely follows the style of the above grammars. Part of the intuition for the feasibility of specifying CSS in this way is that CSS was designed with restrictions that avoid requiring slow evaluation with techniques such as iterative constraint solving. In our encoding, each CSS display type is represented by one or more classes in our system. CSS's normalization algorithm largely leads to our set of interfaces, such as grouping the               and                     display types under interface              . We make heavy use of traits and interfaces, which compromise 23 % and 32 % of the code, respectively. The automatic table layout algorithm was an extension of the above techniques. Finally, similar to the issue with table cells having two parents, a row and a column, out of flow elements also required encodings to support DAG behavior. ", "errors": [{"i": [735, 0, 365, 365, "CSS's"], "s": ["Ass's", "CS S's", "CS-S's"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "Several differences distinguish our experience with specifying CSS layout from the other case studies. Many features were difficult to specify because of many cases or cross-cutting in their semantics. Discussed in Chapter~         , we rely upon automatic checking to assist development, and discussed in Chapter~         , we specify schedule sketches to improve compiler speed and more quickly experiment with parallelization schemes. To further simplify development, we wrote several increasingly large specifications and manually integrated them.", "errors": [{"i": [[737, 0, 0, 0, "Several"], [737, 0, 8, 8, "differences"], [737, 0, 20, 20, "distinguish"], [737, 0, 32, 32, "our"], [737, 0, 36, 36, "experience"], [737, 0, 47, 47, "with"], [737, 0, 52, 52, "specifying"], [737, 0, 63, 63, "CSS"], [737, 0, 67, 67, "layout"], [737, 0, 74, 74, "from"], [737, 0, 79, 79, "the"], [737, 0, 83, 83, "other"], [737, 0, 89, 89, "case"], [737, 0, 94, 94, "studies"]], "s": " Several differences distinguish our experience with specifying CSS l \bayout from the other case studies.\r\nNo complete linkages found.\r\nFound 18 linkages (18 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=0 AND=0 LEN=24)\r\n\r\n    +------------------------------------------------------------Xp-\r\n    |                                 +------------MVp-----------+  \r\n    +---------Wd--------+             +--------Os-------+        |  \r\n    |        +----Dmc---+------Sp-----+        +---D*u--+        +--\r\n    |        |          |             |        |        |        |  \r\nLEFT-WALL several differences.n distinguish.v our experience.n with \r\n\r\n\r\n----------------------------------------------------------+\r\n                            +-----------Jp----------+     |\r\n      +---------MVp---------+        +------Dmc-----+     |\r\n-Mgp--+---Os--+             |   +-DD-+      +---AN--+     |\r\n      |       |             |   |    |      |       |     |\r\nspecifying.v CSS [layout] from the other case.n studies.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "One particularly challenging feature to disentangle relates to ambiguity. CSS  solves seemingly inconsistent input constraints instead of returning an error. For example, if        was extended to support input heights on intermediate nodes, the following conflict would require a graceful interpretation rather than refusing to render:\n                                                                                      ", "errors": [], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "By the original attribute grammar, the outer               should be the size of the biggest child, which would be 500. However, that conflicts with the input constraint of the outer box only being 5 tall. Our CSS grammar inspects for the presence of input attributes and prioritizes them. The analogous resolution for the        example is the following:\n                                                                                                                                                                                       ", "errors": [{"i": [[745, 0, 290, 290, "The"], [745, 0, 294, 294, "analogous"], [745, 0, 304, 304, "resolution"], [745, 0, 315, 315, "for"], [745, 0, 319, 319, "the"], [745, 0, 330, 330, "example"], [745, 0, 338, 338, "is"], [745, 0, 341, 341, "the"], [745, 0, 345, 345, "following"]], "s": " The analogous resolution for the        example is the following:.\r\nNo complete linkages found.\r\nFound 2 linkages (2 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=4 AND=0 LEN=18)\r\n\r\n    +---------------------------------------Xp----------------------\r\n    +-------------Wd------------+-------------Ss-------------+      \r\n    |      +---------Ds---------+        +-----Js----+       +----Os\r\n    |      |       +------A-----+---Mp---+    +--Ds--+       |   +--\r\n    |      |       |            |        |    |      |       |   |  \r\nLEFT-WALL the analogous.a resolution.n for.p the example.n is.v the \r\n\r\n\r\n----------------+\r\n                |\r\nt----+          |\r\n-Ds--+          |\r\n     |          |\r\nfollowing.n [:] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "The grammar uses \"5\" and \"500\" because they were explicitly specified instead of solving for them.  ", "errors": [], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "We found other features to be difficult because they purposefully stray from the direct mathematical interpretation. For example, CSS supports input constraints where a node's width is defined as a proportion of its parent's. If we na \"{i}vely extended        with such a feature, evaluation of the following layout would lead to a degenerate solution:\n                                                                                                     ", "errors": [{"i": [756, 0, 232, 232, "na"], "s": ["an", "DA", "DNA", "ha", "la", "ma", "nab", "nag", "Nan", "nap", "Nat", "nay", "nd", "nm", "no", "NSA", "pa", "QA", "TA"], "e": "spell"}, {"i": [756, 0, 239, 239, "vely"], "s": ["bely", "rely", "very"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "The root node shrinks to fit the middle node, but the middle node must be 50 % of the parent. Direct interpretation leads to a solution of 0 for both widths, but CSS instead leaves the result up to the layout engine implementation. The first reason is that the result looks unappealing: the containers of the leaf node do not appear. The second reason is that, while iterative solvers may avoid some such situations, but at the expense of performance. Implementations instead use non-iterative heuristics, but as seen with tables, implementors struggle to understand them.", "errors": [], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "In summary, our attribute grammar formalism was sufficiently flexible to specify a non-trivial subset of the widely used CSS language. We encountered several key difficulties, and discuss those relating to correctness, safe and effective parallelization, and compiler speed in Chapters~\\ref{???} and~\\ref{???}.", "errors": [], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\section{Related Work}\n               \n      loose formalisms: browser impl (C++), d3 (JavaScript), latex formulas (ML)\n      restricted formalisms: cassowary and hp, UREs\n      AGs: html tables\n             ", "errors": [{"i": [769, 2, 32, 71, "impl"], "s": ["imp", "impel", "imply", "imps"], "e": "spell"}, {"i": [769, 2, 47, 86, "(JavaScript)"], "s": ["Java Script", "Java-Script"], "e": "spell"}, {"i": [769, 3, 29, 149, "cassowary"], "s": [], "e": "spell"}, {"i": [769, 3, 43, 163, "hp"], "s": ["ha", "hap", "he", "hi", "hip", "ho", "hop", "HP", "Hz", "IP", "Ph", "pH", "up"], "e": "spell"}, {"i": [769, 3, 47, 167, "UREs"], "s": ["Ares", "Cures", "Ires", "Lures", "Ores", "Res", "Rues", "Urea", "Urges", "URLs", "Urns", "Uses"], "e": "spell"}, {"i": [769, 4, 6, 178, "AGs"], "s": ["Ads", "AFS", "Age", "Ages", "Ago", "Ams", "As", "Ass", "Bags", "Fags", "Gags", "Gas", "Lags", "Nags", "Rags", "Sags", "Tags", "Wags", "Zags"], "e": "spell"}, {"i": [769, 4, 11, 183, "html"], "s": ["HTML"], "e": "spell"}], "file": "../../thesis/template/chap2.tex"}
,
{"paragraph": "\\section{Motivation and Approach}\n               \n      structure is good for parallelization\n      parallelization needs checking\n      structured parallelism in layout \n             ", "errors": [{"i": [[4, 0, 9, 9, "Motivation"], [4, 0, 20, 20, "and"], [4, 0, 24, 24, "Approach"]], "s": " Motivation and Approach.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 5\r\n\tUnique linkage, cost vector = (UNUSED=6 DIS=0 AND=0 LEN=0)\r\n\r\n[motivation] [and] [Approach] [.] \r\n\r\n", "e": "gram"}, {"i": [[4, 3, 6, 100, "parallelization"], [4, 3, 22, 116, "needs"], [4, 3, 28, 122, "checking"]], "s": " .\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 2\r\n\tUnique linkage, cost vector = (UNUSED=3 DIS=0 AND=0 LEN=0)\r\n\r\n[.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "\\section{Background:  Static Sequential and Task Parallel Visitors}\n\\subsection{Sequential Visitors}  \n               \n      Knuth: synth and inh\n      OAG\n             \n\\subsection{Task Parallel Visitors} \n               \n      FNC-2 / Work stealing\n             ", "errors": [{"i": [13, 3, 13, 132, "synth"], "s": [], "e": "spell"}, {"i": [13, 3, 23, 142, "inh"], "s": ["in", "Inc", "inch", "ink", "inn", "ins"], "e": "spell"}, {"i": [13, 4, 6, 152, "OAG"], "s": ["BAG", "DAG", "FAG", "GAG", "HAG", "JAG", "LAG", "MAG", "NAG", "OAF", "OAK", "OAR", "OAT", "RAG", "SAG", "TAG", "WAG", "ZAG"], "e": "spell"}, {"i": [13, 8, 6, 229, "FNC-"], "s": ["FCC", "INC"], "e": "spell"}], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "\\section{Structured Parallelism in Visitors} \n\\subsection{td, bu, in order} (related to distributed?)\n\\subsection{concurrent} (old paper: unstructured within visit)\n\\subsection{multipass} (any old paper? unstructured within visit)\n\\subsection{nested}", "errors": [{"i": [24, 1, 12, 58, "td"], "s": ["ad", "CD", "ed", "id", "Ltd", "MD", "nd", "rd", "TA", "tb", "Ted", "th", "to", "TV"], "e": "spell"}, {"i": [24, 1, 16, 62, "bu"], "s": ["be", "BS", "bud", "bug", "bum", "bun", "bus", "but", "buy", "by"], "e": "spell"}, {"i": [24, 3, 12, 177, "multipass"], "s": ["multi pass", "multi-pass"], "e": "spell"}], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "\\section{A Behavioral Specification Language}\n\\subsection{Formalism}", "errors": [{"i": [[30, 0, 9, 9, "A"], [30, 0, 11, 11, "Behavioral"], [30, 0, 22, 22, "Specification"], [30, 0, 36, 36, "Language"]], "s": " .\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 2\r\n\tUnique linkage, cost vector = (UNUSED=3 DIS=0 AND=0 LEN=0)\r\n\r\n[.] \r\n\r\n", "e": "gram"}, {"i": [[30, 1, 12, 58, "Formalism"]], "s": " structured parallelism in layout .\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 6\r\n\tUnique linkage, cost vector = (UNUSED=7 DIS=0 AND=0 LEN=0)\r\n\r\n[structured] [parallelism] [in] [layout] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "\\section{Schedule Compilation}\nPhrase as rewrites working in an EDSL w/ templates\n\\subsection{Rewrite rules}\n\\section{Schedule Verification}\n\\subsection{Overview}\n               \n      properties to prove: schedule followed (and complete), dependencies realizable \n      structure of proof\n             \n\\subsection{Axioms}\n               \n      axioms\n      examples from each\n             \n\\subsection{Proof}", "errors": [{"i": [33, 1, 33, 64, "EDSL"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "\\section{Automatically Staging Memory Allocation for SIMD Rendering}\n                    ", "errors": [{"i": [[49, 0, 9, 9, "Automatically"], [49, 0, 23, 23, "Staging"], [49, 0, 31, 31, "Memory"], [49, 0, 38, 38, "Allocation"], [49, 0, 49, 49, "for"], [49, 0, 53, 53, "SIMD"], [49, 0, 58, 58, "Rendering"]], "s": " A Behavioral Specification Language.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 6\r\n\tUnique linkage, cost vector = (UNUSED=7 DIS=0 AND=0 LEN=0)\r\n\r\n[a] [Behavioral] [Specification] [Language] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "\\section{Scheduling Loops}", "errors": [], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "\\section{Evaluation: Layout as Structured Parallel Visits}\n\\subsection{Box model}\n\\subsection{Nested text}\n\\subsection{Grids}", "errors": [{"i": [[55, 0, 9, 9, "Evaluation"], [55, 0, 21, 21, "Layout"], [55, 0, 28, 28, "as"], [55, 0, 31, 31, "Structured"], [55, 0, 42, 42, "Parallel"], [55, 0, 51, 51, "Visits"]], "s": " Formalism.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 3\r\n\tUnique linkage, cost vector = (UNUSED=4 DIS=0 AND=0 LEN=0)\r\n\r\n[formalism] [.] \r\n\r\n", "e": "gram"}, {"i": [[55, 1, 12, 71, "Box"], [55, 1, 16, 75, "model"]], "s": " Automatically Staging Memory Allocation for SIMD Rendering.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 9\r\n\tUnique linkage, cost vector = (UNUSED=10 DIS=0 AND=0 LEN=0)\r\n\r\n[automatically] [Staging] [Memory] [Allocation] [for] [SIMD] [Rendering] [.] \r\n\r\n", "e": "gram"}, {"i": [[55, 2, 12, 94, "Nested"], [55, 2, 19, 101, "text"]], "s": " Evaluation: Layout as Structured Parallel Visits.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 9\r\n\tUnique linkage, cost vector = (UNUSED=10 DIS=0 AND=0 LEN=0)\r\n\r\n[Evaluation] [:] [Layout] [as] [Structured] [Parallel] [Visits] [.] \r\n\r\n", "e": "gram"}, {"i": [[55, 3, 12, 119, "Grids"]], "s": " Box model.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 1\r\n\tUnique linkage, cost vector = (UNUSED=1 DIS=0 AND=0 LEN=2)\r\n\r\n    +---------Xp--------+\r\n    +---Wi--+           |\r\n    |       |           |\r\nLEFT-WALL box.v [model] . \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "\\subsection{SIMD Rendering through Staged Memory Allocation}\nWe evaluate three dimensions of our staged memory allocation approach: flexibility, productivity, and performance. First, it needs to be able to express the rendering tasks that we encounter in GPU data visualization. Second, it should some form of productivity benefit for these tasks. Finally, the performance on those tasks must be fast  enough to support real-time animations and interactions of big data sets.", "errors": [{"i": [[61, 0, 12, 12, "SIMD"], [61, 0, 17, 17, "Rendering"], [61, 0, 27, 27, "through"], [61, 0, 35, 35, "Staged"], [61, 0, 42, 42, "Memory"], [61, 0, 49, 49, "Allocation"]], "s": " Nested text.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 4\r\n\tUnique linkage, cost vector = (UNUSED=5 DIS=0 AND=0 LEN=0)\r\n\r\n[nested] [text] [.] \r\n\r\n", "e": "gram"}, {"i": [[61, 1, 0, 61, "We"], [61, 1, 3, 64, "evaluate"], [61, 1, 12, 73, "three"], [61, 1, 18, 79, "dimensions"], [61, 1, 29, 90, "of"], [61, 1, 32, 93, "our"], [61, 1, 36, 97, "staged"], [61, 1, 43, 104, "memory"], [61, 1, 50, 111, "allocation"], [61, 1, 61, 122, "approach"], [61, 1, 71, 132, "flexibility"], [61, 1, 84, 145, "productivity"], [61, 1, 98, 159, "and"], [61, 1, 102, 163, "performance"]], "s": " Grids.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 3\r\n\tUnique linkage, cost vector = (UNUSED=4 DIS=0 AND=0 LEN=0)\r\n\r\n[Grids] [.] \r\n\r\n", "e": "gram"}, {"i": [[61, 1, 115, 176, "First"], [61, 1, 122, 183, "it"], [61, 1, 125, 186, "needs"], [61, 1, 131, 192, "to"], [61, 1, 134, 195, "be"], [61, 1, 137, 198, "able"], [61, 1, 142, 203, "to"], [61, 1, 145, 206, "express"], [61, 1, 153, 214, "the"], [61, 1, 157, 218, "rendering"], [61, 1, 167, 228, "tasks"], [61, 1, 173, 234, "that"], [61, 1, 178, 239, "we"], [61, 1, 181, 242, "encounter"], [61, 1, 191, 252, "in"], [61, 1, 194, 255, "GPU"], [61, 1, 198, 259, "data"], [61, 1, 203, 264, "visualization"]], "s": " SIMD Rendering through Staged Memory Allocation.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 8\r\n\tUnique linkage, cost vector = (UNUSED=9 DIS=0 AND=0 LEN=0)\r\n\r\n[SIMD] [Rendering] [through] [Staged] [Memory] [Allocation] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "\\subsubsection{Productivity}\nProductivity is difficult to measure. Before using the automation extensions for rendering, we repeatedly encountered bugs in manipulating the allocation calls and memory buffers. The bugs related both to incorrect scheduling and to incorrect pointer arithmetic. Our new design eliminates the possibility of both bugs.", "errors": [{"i": [[66, 0, 15, 15, "Productivity"]], "s": " Second, it should some form of productivity benefit for these tasks. \b\r\nNo complete linkages found.\r\nFound 15 linkages (11 had no P.P. violations) at null count 3\r\n\tLinkage 1, cost vector = (UNUSED=3 DIS=0 AND=0 LEN=21)\r\n\r\n    +---------------------------------------------Xp-------------------------\r\n    +--------Wd-------+                                                      \r\n    |         +---CO--+                    +----------------MVp--------------\r\n    |         +-Xc-+  +--Ss-+-------I------+-------Os------+                 \r\n    |         |    |  |     |              |               |                 \r\nLEFT-WALL second.a , it should.v [some] form.v [of] productivity.n [benefit] \r\n\r\n\r\n--------------------+\r\n                    |\r\n--+-----Jp-----+    |\r\n  |     +--Dmc-+    |\r\n  |     |      |    |\r\nfor.p these tasks.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[66, 1, 38, 67, "Before"], [66, 1, 45, 74, "using"], [66, 1, 51, 80, "the"], [66, 1, 55, 84, "automation"], [66, 1, 66, 95, "extensions"], [66, 1, 77, 106, "for"], [66, 1, 81, 110, "rendering"], [66, 1, 92, 121, "we"], [66, 1, 95, 124, "repeatedly"], [66, 1, 106, 135, "encountered"], [66, 1, 118, 147, "bugs"], [66, 1, 123, 152, "in"], [66, 1, 126, 155, "manipulating"], [66, 1, 139, 168, "the"], [66, 1, 143, 172, "allocation"], [66, 1, 154, 183, "calls"], [66, 1, 160, 189, "and"], [66, 1, 164, 193, "memory"], [66, 1, 171, 200, "buffers"]], "s": " Productivity.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 3\r\n\tUnique linkage, cost vector = (UNUSED=4 DIS=0 AND=0 LEN=0)\r\n\r\n[Productivity] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "One suggestive productivity measure is of how many lines of code the macro abstraction eliminates from our visualizations. We measured the impact on using it for 3 of our visualizations. The first visualization is our HBox language extended with rendering calls, while the other two are interactive reimplementations of popular visualizations: a treemap~[[CITE]] and multiple 3D line graphs~[[CITE]].", "errors": [{"i": [69, 0, 218, 218, "HBox"], "s": ["Box"], "e": "spell"}, {"i": [69, 0, 299, 299, "reimplementations"], "s": ["reimplementation", "re implementations", "re-implementations"], "e": "spell"}, {"i": [69, 0, 346, 346, "treemap"], "s": ["tree map", "tree-map"], "e": "spell"}], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "                 \n\\caption{Lines of Code Before/After Invoking the '@' Macro}\n          \n                                                                                                                                                                                                                                                             ", "errors": [], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "                            \n           \nTable~\\ref{table:macroreduction} compares the lines of code in visualizations before and after we added the macros. Using the macros eliminated 19--44 % of the code. Note that we are \\emph{not} measuring the macro-expanded code, but code that a human wrote.", "errors": [{"i": [83, 2, 17, 58, "macroreduction"], "s": ["macro reduction", "macro-reduction"], "e": "spell"}], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "As shown in Figure~\\ref{fig:stagedallocClient}, the eliminated code is code that was introduced by staging the library calls. Porting unstaged functional graphics calls to the library, is in practice, an alpha renaming of function names.  Using the '@' macro eliminates 19--44 % of the code that would have otherwise been introduced and completely eliminates two classes of bugs (scheduling and pointer arithmetic), so the productivity benefit is non-trivial. ", "errors": [{"i": [89, 0, 28, 28, "stagedallocClient"], "s": [], "e": "spell"}, {"i": [89, 0, 134, 134, "unstaged"], "s": ["unstated", "UN staged", "UN-staged"], "e": "spell"}], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "\\subsubsection{Performance}", "errors": [], "file": "../../thesis/template/chap3.tex"}
,
{"paragraph": "\\section{Motivation: Language Design and Algorithm Implementation}\n\\subsection{The Good: Automating Dependency Management}\n\\subsection{The Bad: Guiding Parallelization}\n\\subsection{The Ugly: Preventing Serialization}\n\\subsection{Algorithm Design}", "errors": [{"i": [[4, 1, 12, 79, "The"], [4, 1, 16, 83, "Good"], [4, 1, 22, 89, "Automating"], [4, 1, 33, 100, "Dependency"], [4, 1, 44, 111, "Management"]], "s": " Lines of Code Before/After Invoking the '@' Macro.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 2\r\n\tUnique linkage, cost vector = (UNUSED=2 DIS=3 AND=0 LEN=24)\r\n\r\n    +--------------------------------Xp--------------------------------+\r\n    +-----------------------Wd----------------------+                  |\r\n    |       +-------------------YP------------------+                  |\r\n    |       |    +-----------JG----------+          |                  |\r\n    |       +-MG-+   +----G---+-----G----+          +-Sp-+----Os---+   |\r\n    |       |    |   |        |          |          |    |         |   |\r\nLEFT-WALL Lines of Code Before/After Invoking [the] ' @[?].v ['] Macro . \r\n\r\n", "e": "gram"}, {"i": [[4, 2, 12, 135, "The"], [4, 2, 16, 139, "Bad"], [4, 2, 21, 144, "Guiding"], [4, 2, 29, 152, "Parallelization"]], "s": " Motivation: Language Design and Algorithm Implementation.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 9\r\n\tUnique linkage, cost vector = (UNUSED=10 DIS=0 AND=0 LEN=0)\r\n\r\n[motivation] [:] [language] [Design] [and] [Algorithm] [Implementation] [.] \r\n\r\n", "e": "gram"}, {"i": [[4, 3, 12, 181, "The"], [4, 3, 16, 185, "Ugly"], [4, 3, 22, 191, "Preventing"], [4, 3, 33, 202, "Serialization"]], "s": " The Good: Automating Dependency Management.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 8\r\n\tUnique linkage, cost vector = (UNUSED=9 DIS=0 AND=0 LEN=0)\r\n\r\n[the] [Good] [:] [automating] [Dependency] [Management] [.] \r\n\r\n", "e": "gram"}, {"i": [[4, 4, 12, 229, "Algorithm"], [4, 4, 22, 239, "Design"]], "s": " The Bad: Guiding Parallelization.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 7\r\n\tUnique linkage, cost vector = (UNUSED=8 DIS=0 AND=0 LEN=0)\r\n\r\n[the] [Bad] [:] [guiding] [Parallelization] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap5.tex"}
,
{"paragraph": "\\section{Holes}\n\\subsection{Generalizing Holes to Unification}", "errors": [{"i": [[10, 0, 9, 9, "Holes"]], "s": " The Ugly: Preventing Serialization.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 7\r\n\tUnique linkage, cost vector = (UNUSED=8 DIS=0 AND=0 LEN=0)\r\n\r\n[the] [Ugly] [:] [preventing] [Serialization] [.] \r\n\r\n", "e": "gram"}, {"i": [[10, 1, 12, 28, "Generalizing"], [10, 1, 25, 41, "Holes"], [10, 1, 31, 47, "to"], [10, 1, 34, 50, "Unification"]], "s": " Algorithm Design.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 4\r\n\tUnique linkage, cost vector = (UNUSED=5 DIS=0 AND=0 LEN=0)\r\n\r\n[Algorithm] [Design] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap5.tex"}
,
{"paragraph": "\\section{Optimized Algorithm: Finding One Schedule}", "errors": [{"i": [[13, 0, 9, 9, "Optimized"], [13, 0, 19, 19, "Algorithm"], [13, 0, 30, 30, "Finding"], [13, 0, 38, 38, "One"], [13, 0, 42, 42, "Schedule"]], "s": " Holes.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 3\r\n\tUnique linkage, cost vector = (UNUSED=4 DIS=0 AND=0 LEN=0)\r\n\r\n[Holes] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap5.tex"}
,
{"paragraph": "\\section{Optimized Algorithm: Autotuning Over Many Schedules}\n\\subsection{Alternation Heuristic: Off-by-one Optimality}\n\\subsection{Enumeration via Incrementalization}", "errors": [{"i": [15, 0, 30, 30, "Autotuning"], "s": ["Auto tuning", "Auto-tuning"], "e": "spell"}, {"i": [15, 1, 35, 97, "Off-by-one"], "s": [], "e": "spell"}, {"i": [15, 2, 28, 148, "Incrementalization"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap5.tex"}
,
{"paragraph": "\\section{Complexity Analysis and the Power of Sketching}\n\\section{Evaluation}\n\\subsection{Case Studies: Sketching in Action}\nShow use in CSS and data viz: \n               \n      when automatic is fine\n      when sketch needed for checking/debugging\n      when sketch needed for sharing\n             \n\\subsection{Speed of synthesis}\nSuccess, fail, enumerate\n\\subsection{Line counts of extensions}\n\\subsection{Loss from greedy heuristic}\n\\subsection{Benefit from autotuning}", "errors": [{"i": [19, 13, 25, 461, "autotuning"], "s": ["auto tuning", "auto-tuning"], "e": "spell"}], "file": "../../thesis/template/chap5.tex"}
,
{"paragraph": "                                                      \n\\section{Overview}", "errors": [], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "For a full language, statically identified parallelization opportunities still require an efficient runtime implementation that exploits them. In this section, we show how to exploit the logical concurrency identified within a tree traversal to optimize for the architectural properties of two types of hardware platforms: MIMD (e.g., multicore) and SIMD (e.g., sub-word SIMD and GPU) hardware. For both types of platforms, we optimize the schedule within a traversal and the data representation. We innovate upon known techniques in two ways:", "errors": [{"i": [[4, 0, 0, 0, "For"], [4, 0, 4, 4, "a"], [4, 0, 6, 6, "full"], [4, 0, 11, 11, "language"], [4, 0, 21, 21, "statically"], [4, 0, 32, 32, "identified"], [4, 0, 43, 43, "parallelization"], [4, 0, 59, 59, "opportunities"], [4, 0, 73, 73, "still"], [4, 0, 79, 79, "require"], [4, 0, 87, 87, "an"], [4, 0, 90, 90, "efficient"], [4, 0, 100, 100, "runtime"], [4, 0, 108, 108, "implementation"], [4, 0, 123, 123, "that"], [4, 0, 128, 128, "exploits"], [4, 0, 137, 137, "them"]], "s": " Generalizing Holes to Unification.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 6\r\n\tUnique linkage, cost vector = (UNUSED=7 DIS=0 AND=0 LEN=0)\r\n\r\n[generalizing] [Holes] [to] [Unification] [.] \r\n\r\n", "e": "gram"}, {"i": [[4, 0, 143, 143, "In"], [4, 0, 146, 146, "this"], [4, 0, 151, 151, "section"], [4, 0, 160, 160, "we"], [4, 0, 163, 163, "show"], [4, 0, 168, 168, "how"], [4, 0, 172, 172, "to"], [4, 0, 175, 175, "exploit"], [4, 0, 183, 183, "the"], [4, 0, 187, 187, "logical"], [4, 0, 195, 195, "concurrency"], [4, 0, 207, 207, "identified"], [4, 0, 218, 218, "within"], [4, 0, 225, 225, "a"], [4, 0, 227, 227, "tree"], [4, 0, 232, 232, "traversal"], [4, 0, 242, 242, "to"], [4, 0, 245, 245, "optimize"], [4, 0, 254, 254, "for"], [4, 0, 258, 258, "the"], [4, 0, 262, 262, "architectural"], [4, 0, 276, 276, "properties"], [4, 0, 287, 287, "of"], [4, 0, 290, 290, "two"], [4, 0, 294, 294, "types"], [4, 0, 300, 300, "of"], [4, 0, 303, 303, "hardware"], [4, 0, 312, 312, "platforms"], [4, 0, 323, 323, "MIMD"], [4, 0, 328, 328, "(e"]], "s": " Optimized Algorithm: Finding One Schedule.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 8\r\n\tUnique linkage, cost vector = (UNUSED=9 DIS=0 AND=0 LEN=0)\r\n\r\n[optimized] [Algorithm] [:] [finding] [One] [Schedule] [.] \r\n\r\n", "e": "gram"}, {"i": [[4, 0, 358, 358, "g"]], "s": " g.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 3\r\n\tUnique linkage, cost vector = (UNUSED=4 DIS=0 AND=0 LEN=0)\r\n\r\n[g] [.] \r\n\r\n", "e": "gram"}, {"i": [[4, 0, 362, 362, "sub-word"], [4, 0, 371, 371, "SIMD"], [4, 0, 376, 376, "and"], [4, 0, 380, 380, "GPU)"], [4, 0, 385, 385, "hardware"]], "s": " sub-word SIMD and GPU) hardware.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 8\r\n\tUnique linkage, cost vector = (UNUSED=9 DIS=0 AND=0 LEN=0)\r\n\r\n[sub-word] [SIMD] [and] [GPU] [)] [hardware] [.] \r\n\r\n", "e": "gram"}, {"i": [[4, 0, 395, 395, "For"], [4, 0, 399, 399, "both"], [4, 0, 404, 404, "types"], [4, 0, 410, 410, "of"], [4, 0, 413, 413, "platforms"], [4, 0, 424, 424, "we"], [4, 0, 427, 427, "optimize"], [4, 0, 436, 436, "the"], [4, 0, 440, 440, "schedule"], [4, 0, 449, 449, "within"], [4, 0, 456, 456, "a"], [4, 0, 458, 458, "traversal"], [4, 0, 468, 468, "and"], [4, 0, 472, 472, "the"], [4, 0, 476, 476, "data"], [4, 0, 481, 481, "representation"]], "s": " For both types of platforms, we optimize the schedule within a trave \brsal and the data representation.\r\nNo complete linkages found.\r\nFound 12 linkages (12 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=2 AND=0 LEN=44)\r\n\r\n    +--------------------------------------------------------------Xp--------\r\n    +---------------------Wd---------------------+                           \r\n    |       +-----------------CO-----------------+                           \r\n    |       +----------------Xc---------------+  |      +----------MVp-------\r\n    |       +------Jp-----+                   |  |      +------Os------+     \r\n    |       |      +--Dmc-+--Mp-+--Jp--+      |  +--Sp--+      +---Ds--+     \r\n    |       |      |      |     |      |      |  |      |      |       |     \r\nLEFT-WALL for.p both.d types.n of platforms.n , we optimize.v the schedule.n \r\n\r\n\r\n-----------------------------------------------------+\r\n                                                     |\r\n                                                     |\r\n---+-------------------Jp-------------------+        |\r\n   |   +-----------------Dsu----------------+        |\r\n   |   |                        +-----AN----+        |\r\n   |   |                        |           |        |\r\nwithin a [traversal] and the data.n representation.n . \r\n\r\n\r\n    +--------------------------------------------------------------Xp--------\r\n    +---------------------Wd---------------------+                           \r\n    |       +-----------------CO-----------------+                           \r\n    |       +----------------Xc---------------+  |      +----------MVp-------\r\n    |       +------Jp-----+                   |  |      +------Os------+     \r\n    |       |      +--Dmc-+--Mp-+--Jp--+      |  +--Sp--+      +---Ds--+     \r\n    |       |      |      |     |      |      |  |      |      |       |     \r\nLEFT-WALL for.p both.d types.n of platforms.n , we optimize.v the schedule.n \r\n\r\n\r\n-----------------------------------------------------+\r\n                                                     |\r\n                                                     |\r\n---+-------------------Jp-------------------+        |\r\n   |                      +-------D*u-------+        |\r\n   |                      |     +-----AN----+        |\r\n   |                      |     |           |        |\r\nwithin a [traversal] and the data.n representation.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[4, 0, 497, 497, "We"], [4, 0, 500, 500, "innovate"], [4, 0, 509, 509, "upon"], [4, 0, 514, 514, "known"], [4, 0, 520, 520, "techniques"], [4, 0, 531, 531, "in"], [4, 0, 534, 534, "two"], [4, 0, 538, 538, "ways"]], "s": " We innovate upon known techniques in two ways:.\r\nNo complete linkages found.\r\nFound 4 linkages (4 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=0 AND=0 LEN=14)\r\n\r\n    +-------------------------------Xp------------------------------+\r\n    |             +---------------MVp--------------+                |\r\n    |             |       +-------Jp-------+       +---Jp---+       |\r\n    +--Wd--+--Sp--+--MVp--+     +-----A----+       |  +-Dmc-+       |\r\n    |      |      |       |     |          |       |  |     |       |\r\nLEFT-WALL we innovate.v upon known.v techniques.n in two ways.n [:] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "                 \n      \\textbf{Semi-static work stealing for MIMD:} MIMD traversals should be optimized for low overheads, load balancing, and locality. Existing techniques such as work stealing provide spatial locality and, with tiling, low overheads. However, dynamic load balancing within a traversal leads to poor temporal locality across traversals. The processor a node is assigned to in one traversal may not be the same one in a subsequent traversal, and as the number of processors increases, the probability of assigning to a different one increases. Our solution dynamically load balances one traversal and, due to similarities across traversals, successfully reuses it.\n      \\textbf{Clustering traversals for SIMD:}  SIMD evaluation is sensitive to divergence across parallel tasks in instruction selection. Visits to different types of tree nodes yield different instruction streams, so na     e vectorization fails for webpages due to their visual variety. Our insight is that similar nodes can be semi-statically identified. Thus \\emph{clustered} nodes will be grouped in the data representation and run in SIMD at runtime.\n%      \\textbf{Automatically staged parallel memory allocation to efficiently combine SIMD layout and SIMD rendering:} We optimized the schedule of memory allocations in the layout computation into an efficient parallel prefix sum. Otherwise, parallel dynamic memory allocation requests would contend over the free memory buffer and void GPU performance benefits. We automated the optimization by reducing the scheduling problem to attribute grammar scheduling and automatically performing the reduction through macro expansion.\n               ", "errors": [{"i": [6, 2, 219, 902, "na"], "s": ["an", "DA", "DNA", "ha", "la", "ma", "nab", "nag", "Nan", "nap", "Nat", "nay", "nd", "nm", "no", "NSA", "pa", "QA", "TA"], "e": "spell"}, {"i": [6, 2, 252, 935, "webpages"], "s": ["webpage", "web pages", "web-pages"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "Our techniques are important and general. They overcame bottlenecks preventing seeing any speedup from parallel evaluation for webpage layout and data visualization. Notably, they are generic to computations over trees, not just layout. An important question going forward is how to combine them as, in principle, they are complementary.", "errors": [{"i": [[12, 0, 42, 42, "They"], [12, 0, 47, 47, "overcame"], [12, 0, 56, 56, "bottlenecks"], [12, 0, 68, 68, "preventing"], [12, 0, 79, 79, "seeing"], [12, 0, 86, 86, "any"], [12, 0, 90, 90, "speedup"], [12, 0, 98, 98, "from"], [12, 0, 103, 103, "parallel"], [12, 0, 112, 112, "evaluation"], [12, 0, 123, 123, "for"], [12, 0, 127, 127, "webpage"], [12, 0, 135, 135, "layout"], [12, 0, 142, 142, "and"], [12, 0, 146, 146, "data"], [12, 0, 151, 151, "visualization"]], "s": " They overcame bottlenecks preventing seeing any speedup from paralle \bl evaluation for webpage layout and data visualization.\r\nNo complete linkages found.\r\nFound 2442 linkages (780 of 1000 random linkages had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=5 AND=0 LEN=31)\r\n\r\n    +-------------------------------------------------------------\r\n    |                                                             \r\n    |                                                    +------Bs\r\n    +---Wd--+---Sp--+-----Op----+------Mg-----+----Os----+--Rn-+--\r\n    |       |       |           |             |          |     |  \r\nLEFT-WALL they overcame.v bottlenecks.n preventing.v seeing.g any \r\n\r\n\r\n-----------------Xp-----------------------------------------------------------\r\n               +-----------------------------------Jp-------------------------\r\n------+        |       +--------------A-------------+----------------AN-------\r\n-Sp---+---MVp--+       |           +-------AN-------+         +-----------AN--\r\n      |        |       |           |                |         |               \r\nspeedup[?].v from parallel.a evaluation.n [for] webpage.n layout.n and data.n \r\n\r\n\r\n-------------------+\r\n---------+         |\r\n---------+         |\r\n---------+         |\r\n         |         |\r\nvisualization[!].n . \r\n\r\n\r\n    +-------------------------------------------------------------\r\n    |                                                             \r\n    |                                                    +------Bs\r\n    +---Wd--+---Sp--+-----Op----+------Mg-----+----Os----+--Rn-+--\r\n    |       |       |           |             |          |     |  \r\nLEFT-WALL they overcame.v bottlenecks.n preventing.v seeing.g any \r\n\r\n\r\n-----------------Xp-----------------------------------------------------------\r\n               +-----------------------------------Jp-------------------------\r\n------+        |       +--------------A-------------+----------------AN-------\r\n-Sp---+---MVp--+       |           +-------AN-------+                     +---\r\n      |        |       |           |                |                     |   \r\nspeedup[?].v from parallel.a evaluation.n [for] webpage.n layout.n and data.n \r\n\r\n\r\n-------------------+\r\n---------+         |\r\n---------+         |\r\n--AN-----+         |\r\n         |         |\r\nvisualization[!].n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[12, 0, 166, 166, "Notably"], [12, 0, 175, 175, "they"], [12, 0, 180, 180, "are"], [12, 0, 184, 184, "generic"], [12, 0, 192, 192, "to"], [12, 0, 195, 195, "computations"], [12, 0, 208, 208, "over"], [12, 0, 213, 213, "trees"], [12, 0, 220, 220, "not"], [12, 0, 224, 224, "just"], [12, 0, 229, 229, "layout"]], "s": " Notably, they are generic to computations over trees, not just layou \bt.\r\nNo complete linkages found.\r\nFound 152 linkages (2 had no P.P. violations) at null count 4\r\n\tLinkage 1, cost vector = (UNUSED=4 DIS=0 AND=0 LEN=18)\r\n\r\n    +-----------------------------------------------Xp------------------------\r\n    +--------Wd-------+                                                       \r\n    |        +---CO---+            +------------MVp------------+              \r\n    |        +-Xc-+   +-Spx+---Pa--+--MVp--+----Jp---+         +--Jp-+        \r\n    |        |    |   |    |       |       |         |         |     |        \r\nLEFT-WALL notably , they are.v generic.a to.r computations.n over trees.n [,] \r\n\r\n\r\n----------------------+\r\n                      |\r\n                      |\r\n                      |\r\n                      |\r\n[not] [just] [layout] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "\\section{MIMD: Semi-static work stealing}\n                 ", "errors": [{"i": [[14, 0, 9, 9, "MIMD"], [14, 0, 15, 15, "Semi-static"], [14, 0, 27, 27, "work"], [14, 0, 32, 32, "stealing"]], "s": " MIMD: Semi-static work stealing.\r\nNo complete linkages found.\r\nFound 2 linkages (2 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=4 AND=0 LEN=8)\r\n\r\n    +----------------------Xp----------------------+\r\n    +---------------Wi--------------+              |\r\n    |                     +---COa---+---Os---+     |\r\n    |                     |         |        |     |\r\nLEFT-WALL [MIMD] [:] Semi-static work.v stealing.g . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "\\section{SIMD Background: Level-Synchronous Breadth-First Tree Traversal}\nThe common baseline for our two SIMD optimizations is to implement parallel preorder and postorder tree traversals as level-synchronous breadth-first parallel tree traversals. Reps first suggested such an approach to parallel attribute grammar evaluation [[CITE]], but did not implement it. Performance bottlenecks led to us deviate from the core representation used by more recent data parallel languages such as NESL [[CITE]] and Data Parallel Haskell [[CITE]]. We discuss our two innovations in the next subsections, but first overview the baseline technique established by existing work.", "errors": [{"i": [18, 1, 76, 150, "preorder"], "s": ["reorder"], "e": "spell"}, {"i": [18, 1, 414, 488, "NESL"], "s": ["NEAL", "NEST"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "              \n                                                                                                                   }   \n                                                                 \\includegraphics[trim=0 0 0 0,clip,width=0.3\\columnwidth]{chapter6/bfslayouttree} } \n                                                                          \\includegraphics[trim=0 0 0 0,clip,width=0.6\\columnwidth]{chapter6/bfslayoutmem} } \n\\caption{\\textbf{SIMD tree traversal as level-synchronous breadth-first iteration with corresponding structure-split data representation.}}\n                        \n            ", "errors": [{"i": [[36, 4, 17, 460, "SIMD"], [36, 4, 22, 465, "tree"], [36, 4, 27, 470, "traversal"], [36, 4, 37, 480, "as"], [36, 4, 40, 483, "level-synchronous"], [36, 4, 58, 501, "breadth-first"], [36, 4, 72, 515, "iteration"], [36, 4, 82, 525, "with"], [36, 4, 87, 530, "corresponding"], [36, 4, 101, 544, "structure-split"], [36, 4, 117, 560, "data"], [36, 4, 122, 565, "representation"]], "s": " SIMD tree traversal as level-synchronous breadth-first iteration wit \bh corresponding structure-split data representation.\r\nNo complete linkages found.\r\nFound 408 linkages (408 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=0 AND=0 LEN=31)\r\n\r\n    +------------------------------------------------------------\r\n    |             +----------------------------------------------\r\n    |             |          +-----------------------------A-----\r\n    +------Wi-----+          |                       +-----------\r\n    |       +-COa-+          |         +-----EAy-----+           \r\n    |       |     |          |         |             |           \r\nLEFT-WALL SIMD tree.v traversal[!].a as.y level-synchronous[!].a \r\n\r\n\r\n-------------------Xp------------------------------------------------------\r\n---------------------Os----------------------------------------------------\r\n------------------------+--------------------------------AN----------------\r\n------A-----------------+                    +----------------A------------\r\n         +------Ah------+                    |                  +------Ah--\r\n         |              |                    |                  |          \r\nbreadth-first[!].a iteration.n [with] corresponding.v structure-split[!].a \r\n\r\n\r\n------------------------+\r\n---------------+        |\r\n---------------+        |\r\n---+           |        |\r\n---+-----AN----+        |\r\n   |           |        |\r\ndata.n representation.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "The na     e tree traversal schedule is to sequentially iterate one level of the tree at a time and  traverse the nodes of a level in parallel. A parallel preorder traversal starts on the root node's level and then proceeds downwards, while a postorder traversal starts on the tree fringe and moves upwards (Figure~\\ref{fig:bfstraversal}~\\ref{fig:bfstraversal:code}). Our MIMD implementation, in contrast, allows one processor to compute on a different tree level than another active processor. In data visualizations, we empirically observed that most of the nodes on a level will dispatch to the same layout instructions, so our na     e traversal schedule avoids instruction divergence.", "errors": [{"i": [44, 0, 4, 4, "na"], "s": ["an", "DA", "DNA", "ha", "la", "ma", "nab", "nag", "Nan", "nap", "Nat", "nay", "nd", "nm", "no", "NSA", "pa", "QA", "TA"], "e": "spell"}, {"i": [44, 0, 155, 155, "preorder"], "s": ["reorder"], "e": "spell"}, {"i": [44, 0, 324, 324, "bfstraversal"], "s": [], "e": "spell"}, {"i": [44, 0, 347, 347, "bfstraversal"], "s": [], "e": "spell"}, {"i": [44, 0, 631, 631, "na"], "s": ["an", "DA", "DNA", "ha", "la", "ma", "nab", "nag", "Nan", "nap", "Nat", "nay", "nd", "nm", "no", "NSA", "pa", "QA", "TA"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "The level-synchronous traversal pattern eliminates many divergent memory accesses by using a corresponding data representation. Adjacent nodes in the schedule are collocated in in memory. Furthermore, individual node attributes are stored in \\emph{column} order through a array-of-structure to structure-of-array conversion. The conversion collocates individual attributes, such as the width attribute of one node being stored next to the width attribute of the node's sibling (Figure~\\ref{fig:bfstraversal:repmem}). The index of a node in a breadth-first traversal of the tree is used to perform a lookup in any of the attribute arrays. The benefit this encoding is that, during SIMD  layout of several adjacent nodes, reads and writes are coalesced into  bulk reads and writes. For example, if a layout pass adds a node's padding to its width, several contiguous paddings and several contiguous widths will be read, and the sum will be stored with a contiguous write. Such optimizations are crucial because the penalty of non-coalesced access is high and, for layout, relatively few computations occur between the reads and writes.", "errors": [{"i": [46, 0, 163, 163, "collocated"], "s": [], "e": "spell"}, {"i": [46, 0, 272, 272, "array-of-structure"], "s": [], "e": "spell"}, {"i": [46, 0, 294, 294, "structure-of-array"], "s": [], "e": "spell"}, {"i": [46, 0, 340, 340, "collocates"], "s": [], "e": "spell"}, {"i": [46, 0, 494, 494, "bfstraversal"], "s": [], "e": "spell"}, {"i": [46, 0, 507, 507, "repmem"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "Full implementation of the data representation poses several subtleties. \n               \n      \\textbf{Level representation.} To eliminate traversal overhead, a summary provides the index of the first and last node on each level of a tree. Such a summary provides  data range information for launching the parallel kernels that evaluate the nodes of a level as well as the information for how to proceed to the next level.\n      \\textbf{Edge representation.} A node may need multiple named lists of children, such as an HTML table with a header, footer, and an arbitrary number of rows. We encode the table's edges as 3 global arrays of offsets: header, footer, and first-row. To support iterating across rows, we also introduce a 4th array to encode whether a node is the last sibling. Thus, any named edge introduces a global array for the offset of the pointed-to node, and for iteration, a shared global array reporting whether a node at a particular index is the end of a list.\n      \\textbf{Memory compression.} Allocating an array the size of the tree for every type of node attribute wastes memory. We instead statically compute the maximum number of attributes required for any type of node, allocate an array for each one, and map the attributes of different types of nodes into different arrays. For example, in a language of HBox nodes as Circle nodes who have attributes 'r' and 'angle', 4 arrays will be allocated. The HBox requires an array for each of the attributes 'w', 'h', 'x', and 'y' while the Circle nodes only require two arrays. Each node has one type, and if that that type is HBox, the node's entry in the first array will contain the 'w' attribute. If the node has type Circle, the node's entry in the first entry will contain the 'r' attribute.\n      \\textbf{Tiling.} Local structural mutations to a tree such as adding or removing nodes should not force global modifications. As most SIMD hardware has limited vector lengths (e.g., 32 elements wide), we split our representation into blocks. Adding nodes may require allocation of a new block and reorganization of the old and new block. Likewise, after successive additions or deletions, the overall structure may need to be compacted. Such techniques are standard for file systems, garbage collectors, and databases.\n             ", "errors": [{"i": [48, 4, 354, 1338, "HBox"], "s": ["Box"], "e": "spell"}, {"i": [48, 4, 450, 1434, "HBox"], "s": ["Box"], "e": "spell"}, {"i": [48, 4, 620, 1604, "HBox"], "s": ["Box"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "In summary, our basic SIMD tree traversal schedule and data representation descend from the approach of NESL [[CITE]] and Data Parallel Haskell [[CITE]]. Previous work shows how to generically convert a tree of structures into a structure of arrays. Those approaches do not support statically unbounded nesting depth (i.e., tree depth), but our system supports arbitrary tree depth because our transformation is not as generic.  ", "errors": [{"i": [57, 0, 104, 104, "NESL"], "s": ["NEAL", "NEST"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "A key property of all of our systems, however, is that the structure of the tree is fixed prior to the traversals.  In contrast, for example, parallel breadth-first traversals of graphs will dynamically find a minimum spanning tree [[CITE]]. Such dynamic alternatives incur unnecessary overheads when performing a sequence of traversals and sacrifice memory coalescing opportunities. Layout is often a repetitive process, whether due to multiple tree traversals for one invocation or an animation incurring multiple invocations, so costs in creating an optimized data representation and schedule are worth paying.", "errors": [{"i": [[59, 0, 0, 0, "A"], [59, 0, 2, 2, "key"], [59, 0, 6, 6, "property"], [59, 0, 15, 15, "of"], [59, 0, 18, 18, "all"], [59, 0, 22, 22, "of"], [59, 0, 25, 25, "our"], [59, 0, 29, 29, "systems"], [59, 0, 38, 38, "however"], [59, 0, 47, 47, "is"], [59, 0, 50, 50, "that"], [59, 0, 55, 55, "the"], [59, 0, 59, 59, "structure"], [59, 0, 69, 69, "of"], [59, 0, 72, 72, "the"], [59, 0, 76, 76, "tree"], [59, 0, 81, 81, "is"], [59, 0, 84, 84, "fixed"], [59, 0, 90, 90, "prior"], [59, 0, 96, 96, "to"], [59, 0, 99, 99, "the"], [59, 0, 103, 103, "traversals"]], "s": " A key property of all of our systems, however, is that the structure \b of the tree is fixed prior to the traversals.\r\nNo complete linkages found.\r\nFound 267 linkages (78 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=1 AND=0 LEN=43)\r\n\r\n    +---------------------------------------------------------------------\r\n    +--------Wd--------+-----------------------Ss----------------------+  \r\n    |     +-----Dsu----+               +----Jp---+           +----E----+--\r\n    |     |   +---AN---+--Mp--+-J-+-Mp-+  +--Dmc-+     +--Xd-+--Xc-+   |  \r\n    |     |   |        |      |   |    |  |      |     |     |     |   |  \r\nLEFT-WALL a key.n property.n of all.a of our systems.n , however.e , is.v \r\n\r\n\r\n----Xp---------------------------------------------------------\r\n------Ost-------+       +---Js---+           +----MVp----+-----\r\n        +--D*u--+---Mp--+  +--Ds-+-----Mv----+      +IDBB+  +--\r\n        |       |       |  |     |           |      |    |  |  \r\n[that] the structure.n of the tree.n [is] fixed.v prior to the \r\n\r\n\r\n----------------+\r\n                |\r\nJp-----+        |\r\n-Dmc---+        |\r\n       |        |\r\ntraversals[!].n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[59, 0, 116, 116, "In"], [59, 0, 119, 119, "contrast"], [59, 0, 129, 129, "for"], [59, 0, 133, 133, "example"], [59, 0, 142, 142, "parallel"], [59, 0, 151, 151, "breadth-first"], [59, 0, 165, 165, "traversals"], [59, 0, 176, 176, "of"], [59, 0, 179, 179, "graphs"], [59, 0, 186, 186, "will"], [59, 0, 191, 191, "dynamically"], [59, 0, 203, 203, "find"], [59, 0, 208, 208, "a"], [59, 0, 210, 210, "minimum"], [59, 0, 218, 218, "spanning"], [59, 0, 227, 227, "tree"], [59, 0, 234, 234, "CITE"]], "s": " In contrast, for example, parallel breadth-first traversals of graph \bs will dynamically find a minimum spanning tree [[CITE].\r\nNo complete linkages found.\r\nFound 344 linkages (336 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=4 AND=0 LEN=53)\r\n\r\n    +-----------------------------------------------------------------\r\n    +-----------------------------------Wd----------------------------\r\n    |      +--------------------------------CO------------------------\r\n    |      |                     +---------------------CO-------------\r\n    |      +-----Xc-----+        |           +---------------A--------\r\n    |      +--Jp--+     |  +IDBXA+-Xc-+      |              +-------Ah\r\n    |      |      |     |  |     |    |      |              |         \r\nLEFT-WALL in contrast.n , for example , parallel.a breadth-first[!].a \r\n\r\n\r\n---------------Xp------------------------------------------------------------\r\n-------+                                                                     \r\n-------+                                          +--------------Os----------\r\n-------+                                          |   +------------Ds--------\r\n-------+-----------Sp----------+---------I--------+   |     +---------A------\r\n-------+----Mp---+--Jp-+       |        +----Em---+   |     |          +---AN\r\n       |         |     |       |        |         |   |     |          |     \r\ntraversals[!].n of graphs.n will.v dynamically find.v a minimum.a spanning.g \r\n\r\n\r\n--------------------+\r\n                    |\r\n---+                |\r\n---+                |\r\n---+----MXs----+    |\r\n---+       +-Xd+Xc+ |\r\n   |       |   |  | |\r\ntree.n [[] [ CITE ] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "\\section{Input-dependent Clustering for SIMD Evaluation}\n                 ", "errors": [{"i": [[61, 0, 9, 9, "Input-dependent"], [61, 0, 25, 25, "Clustering"], [61, 0, 36, 36, "for"], [61, 0, 40, 40, "SIMD"], [61, 0, 45, 45, "Evaluation"]], "s": " Input-dependent Clustering for SIMD Evaluation.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 7\r\n\tUnique linkage, cost vector = (UNUSED=8 DIS=0 AND=0 LEN=0)\r\n\r\n[Input-dependent] [Clustering] [for] [SIMD] [Evaluation] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "\\section{Evaluation}", "errors": [], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "\\caption{\\textbf{Speedups and strong scaling across different backends (Back) and hardware}. Baseline is a sequential traversal with no data layout optimizations. FTL is our multicore tree traversal library. Left columns show total speedup (including data layout optimizations by our code generator) and right columns show just parallel speedup. Server = Opteron 2356, laptop = Intel Core i7, mobile = Atom 330.}\n                  \n           ", "errors": [{"i": [83, 0, 62, 62, "backends"], "s": ["back ends", "back-ends"], "e": "spell"}, {"i": [83, 0, 163, 163, "FTL"], "s": ["FT", "FTP", "STL", "TTL"], "e": "spell"}, {"i": [83, 0, 355, 355, "Opteron"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "\\subsection{MIMD Data Representation and Scheduling Optimizations}\nBy statically exposing traversal structure (e.g., \\sched{parPre}) to our code generators, we observe sequential and parallel speedups. We separately evaluate the importance of the data representation optimizations from the scheduling ones on random 500-1000 node documents in the            language. Finally, we examine the parallel benefit on webpages.", "errors": [{"i": [87, 1, 57, 124, "parPre"], "s": [], "e": "spell"}, {"i": [87, 1, 345, 412, "webpages"], "s": ["webpage", "web pages", "web-pages"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "We first evaluate the perform of our task scheduler (FTL in Table~\\ref{tab:diffhw}).  Our comparison point is Intel's TBB~                dynamic task scheduler that performs work stealing~           , which was the most efficient third-party work stealing library that we tried. We included our data layout optimizations in all calculations because, without them, we saw no speedup.  TBB causes slowdowns until achieving no cost (nor benefit) at 8 cores. Our insight is that it suffered from high overheads: switching to scheduling tiles by using our optimized data representation improved performance. Our semi-static working stealing scheduler, however, achieved a 6.9X speedup on 8 cores. We did not see significant further speedups for higher core counts, and hypothesize that it is due to the socket jump. We experimented with other schedulers, such as a simple for-loop over tiles near the fringe of the tree, but the achieved 2X speedup is much lower than the 6.9X of our semi-static work stealer.", "errors": [{"i": [91, 0, 52, 52, "(FTL"], "s": ["FT", "FTP", "STL", "TTL"], "e": "spell"}, {"i": [91, 0, 75, 75, "diffhw"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "Data representation was key to achieving parallel speedups. It achieved 1.2X-1.4X speedups for sequential processing (Table~\\ref{tab:diffhw}). However, on 4 cores, it improved performance from 2.8X without data representation optimizations to 5.2X when using them. The difference is 1.9X: our data representation optimizations both complement and improve scheduling optimizations. Without them, parallel performance was poor.", "errors": [{"i": [94, 0, 133, 133, "diffhw"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "\\caption{\\textbf{Parallel CSS layout engine}. Run on a 2356 Opteron.}\n                   \n           ", "errors": [{"i": [107, 0, 60, 60, "Opteron"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "Table~\\ref{fig:cssperf} shows the parallel speedup on running our 9 pass layout engine for two popular web pages that render faithfully with it: Wikipedia and the XKCD blog. Note that the benchmarks do \\emph{not} include sequential speedups. The best performance of TBB was a 1.8X speedup on 4 cores, and its speedup on 8 cores was 1.2X. In comparison, our scheduler achieved 2.8X on 2 cores and 3.2X on 8X. Our insight as to why we did not see further benefits is overheads. Across our benchmarks, we generally saw speedups when sequential traversals took longer than a certain amount, but because so many traversals are used for CSS, enough of them are small enough that we do not expect strong scaling. Our intuition is that either a full layout engine is complicated enough that the sequential cost of each traversal will be higher than in our prototype, or even more aggressive data representation optimizations should be performed. As is, we have demonstrated significant 3X+ speedups on real workloads from just the parallelization.", "errors": [{"i": [111, 0, 15, 15, "cssperf"], "s": [], "e": "spell"}, {"i": [111, 0, 145, 145, "Wikipedia"], "s": [], "e": "spell"}, {"i": [111, 0, 163, 163, "XKCD"], "s": [], "e": "spell"}, {"i": [111, 0, 168, 168, "blog"], "s": ["bldg", "blob", "bloc", "blot", "blow", "bog", "clog", "flog", "log", "slog"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "              \n          \n\\includegraphics[trim=0 0 0 0,clip,width=1.0\\columnwidth]{chapter6/gpuspeedup}\n\\caption{\\textbf{Sequential and Parallel Benefits of Breadth-First Layout and Staged Allocation.} Allocation is merged into the 4th stage and buffer indexing and tessellation form the rendering pass. JavaScript variants use HTML5 canvas drawing primitives while WebCL does not include WebGL painting time ($<$ 5ms). Thin vertical bars indicate standard deviation and horizontal bars show deadlines for animation and hand-eye interaction.}\n                        \n            ", "errors": [{"i": [114, 3, 200, 305, "JavaScript"], "s": ["Java Script", "Java-Script"], "e": "spell"}, {"i": [114, 3, 262, 367, "WebCL"], "s": [], "e": "spell"}, {"i": [114, 3, 285, 390, "WebGL"], "s": [], "e": "spell"}, {"i": [114, 3, 311, 416, "ms)"], "s": ["ams", "as", "BS", "CS", "is", "m's", "ma", "mb", "MD", "me", "ml", "mm", "Mr", "Mrs", "Ms", "MST", "MTS", "my", "OS", "RMS", "SMS", "us", "VMS", "vs"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "\\subsection{Baseline SIMD Speedups (GPU)}\nWe evaluate the sequential and parallel performance benefits of our baseline breadth-first layout.   For an animation to achieve 24fps, the time spent to process a frame should not exceed 42ms, and for eye-hand interactions, 100ms (10fps). We examine the case of a 5 pass treemap that supports live filtering over 100,000 data points. The first 3 passes are purely devoted to layout, the 4th pass includes layout computations and allocation requests, and the 5th pass propagates buffer indices and performs tessellation. ", "errors": [{"i": [122, 1, 131, 173, "fps"], "s": ["BPS", "f's", "fops", "ftps", "GPS", "ups"], "e": "spell"}, {"i": [122, 1, 190, 232, "ms"], "s": ["ams", "as", "BS", "CS", "is", "m's", "ma", "mb", "MD", "me", "ml", "mm", "Mr", "Mrs", "Ms", "MST", "MTS", "my", "OS", "RMS", "SMS", "us", "VMS", "vs"], "e": "spell"}, {"i": [122, 1, 228, 270, "ms"], "s": ["ams", "as", "BS", "CS", "is", "m's", "ma", "mb", "MD", "me", "ml", "mm", "Mr", "Mrs", "Ms", "MST", "MTS", "my", "OS", "RMS", "SMS", "us", "VMS", "vs"], "e": "spell"}, {"i": [122, 1, 234, 276, "fps)"], "s": ["BPS", "f's", "fops", "ftps", "GPS", "ups"], "e": "spell"}, {"i": [122, 1, 272, 314, "treemap"], "s": ["tree map", "tree-map"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "We compare 3 backends for our compiler: canonical JavaScript (a tree of nodes), JavaScript over our structure-split breadth-first tree layout (and with typed arrays~[[CITE]]), and WebCL for the GPU.  The first two variants invoke HTML5 canvas drawing primitives, while the last invokes WebGL (GPU) painting primitives over vertex buffers computed in the rendering pass. The time for WebGL painting calls are not shown, but they take less than 5ms. Each variant is repeated 15 times on a 4 core 2012 2.66GHz Intel Core i7 with 8 GB memory and a 1024 MB NVIDIA GeForce GT 650M graphics card.", "errors": [{"i": [125, 0, 13, 13, "backends"], "s": ["back ends", "back-ends"], "e": "spell"}, {"i": [125, 0, 50, 50, "JavaScript"], "s": ["Java Script", "Java-Script"], "e": "spell"}, {"i": [125, 0, 80, 80, "JavaScript"], "s": ["Java Script", "Java-Script"], "e": "spell"}, {"i": [125, 0, 180, 180, "WebCL"], "s": [], "e": "spell"}, {"i": [125, 0, 286, 286, "WebGL"], "s": [], "e": "spell"}, {"i": [125, 0, 383, 383, "WebGL"], "s": [], "e": "spell"}, {"i": [125, 0, 444, 444, "ms"], "s": ["ams", "as", "BS", "CS", "is", "m's", "ma", "mb", "MD", "me", "ml", "mm", "Mr", "Mrs", "Ms", "MST", "MTS", "my", "OS", "RMS", "SMS", "us", "VMS", "vs"], "e": "spell"}, {"i": [125, 0, 552, 552, "NVIDIA"], "s": [], "e": "spell"}, {"i": [125, 0, 559, 559, "GeForce"], "s": [], "e": "spell"}, {"i": [125, 0, 567, 567, "GT"], "s": ["AT", "ET", "FT", "GB", "GET", "GIT", "GM", "GO", "GOT", "GUT", "IT", "ST"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "We first examine  the significant sequential benefits.The first 4 groups of columns in Figure~\\ref{fig:treemapjsgpu} shows the average time spent on different layout passes and the 6th on the pass for buffer index computation and tessellation. Performing compiler optimizations enables a 14X sequential speedup on layout in the Chrome web browser. No speedup is observed in the rendering pass because the time is dominated by HTML5 canvas calls. We hypothesize part of the sequential benefit is related to our clustering optimization: all of the nodes in a level have the same type, so implicit optimizations such as branch prediction should perform better. Finally, we note that while sequential layout time is a magnitude too slow for real-time animation, our prototype is within 54ms for real-time interaction (ignoring rendering).", "errors": [{"i": [127, 0, 103, 103, "treemapjsgpu"], "s": [], "e": "spell"}, {"i": [127, 0, 784, 784, "ms"], "s": ["ams", "as", "BS", "CS", "is", "m's", "ma", "mb", "MD", "me", "ml", "mm", "Mr", "Mrs", "Ms", "MST", "MTS", "my", "OS", "RMS", "SMS", "us", "VMS", "vs"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "Parallel speedups are also significant. WebCL (GPU) evaluation of layout is 5X faster than sequential. The impact of compiling JavaScript vs. C (WebCL) on the benchmark is unclear: JavaScript is generally a magnitude slower than native code, except the runtime WebCL compiler is not running at high optimization levels. The benefits for parallel computation of the buffer indices and tessellation is much more clear: the speedup is 31X. ", "errors": [{"i": [129, 0, 40, 40, "WebCL"], "s": [], "e": "spell"}, {"i": [129, 0, 127, 127, "JavaScript"], "s": ["Java Script", "Java-Script"], "e": "spell"}, {"i": [129, 0, 144, 144, "(WebCL)"], "s": [], "e": "spell"}, {"i": [129, 0, 181, 181, "JavaScript"], "s": ["Java Script", "Java-Script"], "e": "spell"}, {"i": [129, 0, 261, 261, "WebCL"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "              \n          \n\\includegraphics[trim=0 0 0 0,clip,width=1.0\\columnwidth]{chapter6/gpuvscpu}\n\\caption{\\textbf{Multicore vs. GPU Acceleration of Layout.} Benchmark on an early version of the treemap visualization and does not include rendering pass.}\n                    \n            ", "errors": [{"i": [131, 3, 97, 200, "treemap"], "s": ["tree map", "tree-map"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "To better understand the benefit of parallelization, we compared running the layout traversals using multicore vs. GPU acceleration (Figure~\\ref{fig:cpuvsgpu}) for an early prototype of the layout traversals. Both use breadth-first traversals compiled with OpenCL, except differ on the hardware target. We see that a server-grade multiprocessor (32-core AMD Opteron 2356) can outperform a laptop GPU, but the comparison is unfair in terms of power consumption. TODO compare power ratings.", "errors": [{"i": [138, 0, 149, 149, "cpuvsgpu"], "s": [], "e": "spell"}, {"i": [138, 0, 257, 257, "OpenCL"], "s": [], "e": "spell"}, {"i": [138, 0, 354, 354, "AMD"], "s": ["AD", "ADD", "AID", "AM", "AMA", "AMID", "AMP", "AMS", "AMY", "AND", "MAD", "MD"], "e": "spell"}, {"i": [138, 0, 358, 358, "Opteron"], "s": [], "e": "spell"}, {"i": [138, 0, 461, 461, "TODO"], "s": ["TODD", "TOGO", "TOO", "TOTO", "TO DO", "TO-DO"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "Ultimately, when the sequential and parallel optimizations are combined, we see an end-to-end speedup of 54X. It is high enough such that it enables real-time animation for our data set, not just real-time user interaction.", "errors": [{"i": [141, 0, 83, 83, "end-to-end"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "\\subsection{SIMD Clustering}\nWe evaluate several aspects of our clustering approach. First, we examine applicability to various visualizations. Second, we evaluate the speed and performance benefit. Clustering provides invariants that benefit more than just vectorization, so we distinguish sequential vs. parallel speedups. Finally, there are different options in what clusters to form, so for each stage of evaluation, we compare impact.", "errors": [{"i": [[144, 0, 12, 12, "SIMD"], [144, 0, 17, 17, "Clustering"]], "s": " SIMD Clustering.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 4\r\n\tUnique linkage, cost vector = (UNUSED=5 DIS=0 AND=0 LEN=0)\r\n\r\n[SIMD] [Clustering] [.] \r\n\r\n", "e": "gram"}, {"i": [[144, 1, 170, 199, "Clustering"], [144, 1, 181, 210, "provides"], [144, 1, 190, 219, "invariants"], [144, 1, 201, 230, "that"], [144, 1, 206, 235, "benefit"], [144, 1, 214, 243, "more"], [144, 1, 219, 248, "than"], [144, 1, 224, 253, "just"], [144, 1, 229, 258, "vectorization"], [144, 1, 244, 273, "so"], [144, 1, 247, 276, "we"], [144, 1, 250, 279, "distinguish"], [144, 1, 262, 291, "sequential"], [144, 1, 273, 302, "vs"]], "s": " Clustering provides invariants that benefit more than just vectoriza \btion, so we distinguish sequential vs.\r\nNo complete linkages found.\r\nFound 40 linkages (24 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=0 AND=0 LEN=27)\r\n\r\n    +-----------------------------------------------------------------------X\r\n    |           +----------------------------------------------CC------------\r\n    |           |                        +-----------Bp-----------+-----MVt--\r\n    +-----Wd----+----Ss*g---+-----Op-----+------R------+----RS----+---Om--+  \r\n    |           |           |            |             |          |       |  \r\nLEFT-WALL clustering.v provides.v invariants[!].n that.misc-r benefit.v more \r\n\r\n\r\np----------------------------------------------------------------------+\r\n----------------------------------+                                    |\r\n--+--------Osc-------+            |                                    |\r\n  |     +------A-----+         +Xd+Wd+---Sp--+                         |\r\n  |     |            |         |  |  |       |                         |\r\nthan just.a vectorization[!].n , so we distinguish.v [sequential] [vs] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[144, 1, 296, 325, "Finally"], [144, 1, 305, 334, "there"], [144, 1, 311, 340, "are"], [144, 1, 315, 344, "different"], [144, 1, 325, 354, "options"], [144, 1, 333, 362, "in"], [144, 1, 336, 365, "what"], [144, 1, 341, 370, "clusters"], [144, 1, 350, 379, "to"], [144, 1, 353, 382, "form"], [144, 1, 359, 388, "so"], [144, 1, 362, 391, "for"], [144, 1, 366, 395, "each"], [144, 1, 371, 400, "stage"], [144, 1, 377, 406, "of"], [144, 1, 380, 409, "evaluation"], [144, 1, 392, 421, "we"], [144, 1, 395, 424, "compare"], [144, 1, 403, 432, "impact"]], "s": " Finally, there are different options in what clusters to form, so fo \br each stage of evaluation, we compare impact.\r\nNo complete linkages found.\r\nFound 44 linkages (22 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=2 AND=0 LEN=58)\r\n\r\n    +----------------------------------------------------------------------\r\n    |                                                                      \r\n    |                                                                      \r\n    |                   +--------------------------------CC----------------\r\n    +---------Wd--------+     +------------MVp-----------+                 \r\n    |         +----CO---+     +--------Opt--------+      |                 \r\n    |         +--Xc-+   +-SFp-+        +----Am----+      +-Js+--Ss*d-+--MVp\r\n    |         |     |   |     |        |          |      |   |       |     \r\nLEFT-WALL finally.e , there are.v different.a options.n in what clusters.v \r\n\r\n\r\n---Xp-------------------------------------------------------------------------\r\n               +--------------------Wd-------------------+                    \r\n               |   +------------------CO-----------------+                    \r\n---------------+   +----------------Xc----------------+  |                    \r\n               |   +-------------Js------------+      |  |                    \r\n               |   |     +----------Ds---------+      |  |                    \r\n--+--Jp-+   +Xd+   |     |     +-------AN------+      |  +--Sp-+----Os---+    \r\n  |     |   |  |   |     |     |               |      |  |     |         |    \r\nto.r form.n , so for.p each stage.n [of] evaluation.n , we compare.v impact.n \r\n\r\n\r\n+\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n. \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "              \n          \n\\includegraphics[trim=0 0 0 0,clip,width=1.0\\columnwidth]{chapter6/csscompression}\n\\caption{\\textbf{Compression ratio for different CSS clusterings.} Bars depict compression ratio (number of clusters over number of nodes). Recursive clustering is for the reduce pattern, level-only for the map pattern. ID is an identifier set by the C3 browser for nodes sharing the same style parse information while value is by clustering on actual style field values.}\n                          \n            ", "errors": [{"i": [[147, 3, 17, 126, "Compression"], [147, 3, 29, 138, "ratio"], [147, 3, 35, 144, "for"], [147, 3, 39, 148, "different"], [147, 3, 49, 158, "CSS"], [147, 3, 53, 162, "clusterings"]], "s": " Compression ratio for different CSS clusterings.\r\nNo complete linkages found.\r\nFound 8 linkages (8 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=2 AND=0 LEN=12)\r\n\r\n    +--------------------------------Xp--------------------------------+\r\n    +----------------------Wd----------------------+                   |\r\n    |                      +-----------AN----------+                   |\r\n    |           +----AN----+               +---Am--+----Ss----+        |\r\n    |           |          |               |       |          |        |\r\nLEFT-WALL compression.n ratio.n [for] different.a CSS clusterings[!].v . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[147, 3, 67, 176, "Bars"], [147, 3, 72, 181, "depict"], [147, 3, 79, 188, "compression"], [147, 3, 91, 200, "ratio"], [147, 3, 97, 206, "(number"], [147, 3, 105, 214, "of"], [147, 3, 108, 217, "clusters"], [147, 3, 117, 226, "over"], [147, 3, 122, 231, "number"], [147, 3, 129, 238, "of"], [147, 3, 132, 241, "nodes)"]], "s": " Bars depict compression ratio (number of clusters over number of nod \bes).\r\nNo complete linkages found.\r\nFound 4 linkages (4 had no P.P. violations) at null count 3\r\n\tLinkage 1, cost vector = (UNUSED=3 DIS=1 AND=0 LEN=25)\r\n\r\n    +------------------------------------------------Xp-----------------------\r\n    |                                                       +-----------------\r\n    |                           +------------MXsx-----------+              +--\r\n    +---Wd---+---Sp--+----Os----+               +-----Xd----+--Jp--+---Mp--+  \r\n    |        |       |          |               |           |      |       |  \r\nLEFT-WALL bars.n depict.v compression.n [ratio] ( [number] of clusters.n over \r\n\r\n\r\n------------------------+\r\n--Xc------------------+ |\r\n-------Jp--------+    | |\r\n    +-----AN-----+    | |\r\n    |            |    | |\r\nnumber.n [of] nodes.n ) . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}, {"i": [[147, 3, 140, 249, "Recursive"], [147, 3, 150, 259, "clustering"], [147, 3, 161, 270, "is"], [147, 3, 164, 273, "for"], [147, 3, 168, 277, "the"], [147, 3, 172, 281, "reduce"], [147, 3, 179, 288, "pattern"], [147, 3, 188, 297, "level-only"], [147, 3, 199, 308, "for"], [147, 3, 203, 312, "the"], [147, 3, 207, 316, "map"], [147, 3, 211, 320, "pattern"]], "s": " Recursive clustering is for the reduce pattern, level-only for the m \bap pattern.\r\nNo complete linkages found.\r\nFound 24 linkages (24 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=2 AND=0 LEN=13)\r\n\r\n                                                                          +---\r\n                                                                          +---\r\n    +---------Ss---------+    +---------Js---------+---------MXsx---------+   \r\n    +-----Mg----+        +-Pp-+    +-------Ds------+     +-------Xd-------+   \r\n    |           |        |    |    |               |     |                |   \r\nRecursive clustering.v is.v for.p the [reduce] pattern.n , [level-only] for.p \r\n\r\n\r\n--------Xc----------+\r\n-----Js-------+     |\r\n +-----Ds-----+     |\r\n |    +---AN--+     |\r\n |    |       |     |\r\nthe map.n pattern.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "\\subsubsection{Applicability}", "errors": [], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "We examined idealized speedup for several workloads:", "errors": [{"i": [[160, 0, 0, 0, "We"], [160, 0, 3, 3, "examined"], [160, 0, 12, 12, "idealized"], [160, 0, 22, 22, "speedup"], [160, 0, 30, 30, "for"], [160, 0, 34, 34, "several"], [160, 0, 42, 42, "workloads"]], "s": " We examined idealized speedup for several workloads:.\r\nNo complete linkages found.\r\nFound 3 linkages (3 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=0 AND=0 LEN=12)\r\n\r\n    +--------------------------------------Xp---------------------------------\r\n    |             +---------------MVp--------------+                          \r\n    |             +-----------Os----------+        +--------Jp--------+       \r\n    +--Wd--+--Sp--+          +------A-----+        |      +----Dmc----+       \r\n    |      |      |          |            |        |      |           |       \r\nLEFT-WALL we examined.v idealized.v speedup[?].n for.p several workloads[!].n \r\n\r\n\r\n----+\r\n    |\r\n    |\r\n    |\r\n    |\r\n[:] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "      \\textbf{Synthetic.} For a controlled synthetic benchmark, we simulated the effect of increasing number of clusters on speedup for various SIMD architectures.  Our simulation assumes perfect speedups for SIMD evaluation of nodes run together on a SIMD unit. The ideal speedup is a function of the minimum of the SIMD unit's length (for longer clusters, multiple SIMD invocations are mandatory) and the number of clusters (at least one SIMD step is necessary for each cluster).   Figure~\\ref{fig:simulatedclusteringspeedup} shows, for architectures of different vector length, that the simulated speedup from clustering (solid black line with circles) is close to the ideal speedup (solid green line).", "errors": [{"i": [164, 0, 500, 500, "simulatedclusteringspeedup"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "      \\textbf{Data visualization.} For our data visualizations, we found that, across the board, all of the nodes of a level shared the same type. For example, our visualization for multiple line graphs puts the root node on the first level, the axis for each line graph on the second level, and all of the actual line segments on the third level. ", "errors": [{"i": [[166, 0, 14, 14, "Data"], [166, 0, 19, 19, "visualization"]], "s": " Data visualization.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 4\r\n\tUnique linkage, cost vector = (UNUSED=5 DIS=0 AND=0 LEN=0)\r\n\r\n[Data] [visualization] [.] \r\n\r\n", "e": "gram"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "      \\textbf{CSS.} We analyzed potential speedup on webpages. Webpages are a challenging case because an individual webpage features high visual diversity, with popular sites using an average of 27KB of style data per page.~                                                                   . We picked 10 popular websites from the Alexa Top 100 US websites that rendered sufficiently correctly in the C3~[[CITE]] web browser. It was also challenging in practice because it required clustering based on individual node attributes, not just the node type.", "errors": [{"i": [168, 0, 53, 53, "webpages"], "s": ["webpage", "web pages", "web-pages"], "e": "spell"}, {"i": [168, 0, 63, 63, "Webpages"], "s": ["Webpage", "Web pages", "Web-pages"], "e": "spell"}, {"i": [168, 0, 315, 315, "websites"], "s": ["web sites", "web-sites"], "e": "spell"}, {"i": [168, 0, 333, 333, "Alexa"], "s": ["Alex"], "e": "spell"}, {"i": [168, 0, 350, 350, "websites"], "s": ["web sites", "web-sites"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "Figure~{fig:csscompression} compares how well nodes of a webpage can be clustered. It reports the \\emph{compression ratio}, which divides the number of clusters by the number of nodes. Sequential execution would assign each node to its own cluster, so the ratio would be 1. In contrast, if the tree is actually a list of 100 elements, and the list can be split into 25 clusters, the ratio would be 25 %. Assuming infinite-length vector processors and constant-time evaluation of a node, the compression ratio is the exact inverse of the speedup. A ratio of 1 leads to a 1X speedup, and a compression ratio of 25 % leads to a 4X speedup.", "errors": [{"i": [170, 0, 12, 12, "csscompression"], "s": ["CSS compression", "CSS-compression"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "Clustering each level by attributes that influence control flow achieved a 12 % compression ratio (Figure~{fig:csscompression}): an 8.3X idealized speedup. When we strengthened the clustering condition to enforce stronger invariants in the cluster, such as to consider properties of the parent node, the ratio quickly worsened. Thus, we see that our basic approach is promising for websites on modern subword-SIMD instruction sets, such as a 4-wide SSE (x86) and NEON (ARM), and the more recent 8-wide AVX (x86). Even longer vector lengths are still beneficial because some clusters were long. However, eliminating all divergences requires addressing control flows influenced by attributes of node neighbors, which leads to poor compression ratios. Thus, we emphasize that 8.3X is an upper bound on the idealized speedup: not all branches in a cluster are addressed.\n             ", "errors": [{"i": [[172, 0, 0, 0, "Clustering"], [172, 0, 11, 11, "each"], [172, 0, 16, 16, "level"], [172, 0, 22, 22, "by"], [172, 0, 25, 25, "attributes"], [172, 0, 36, 36, "that"], [172, 0, 41, 41, "influence"], [172, 0, 51, 51, "control"], [172, 0, 59, 59, "flow"], [172, 0, 64, 64, "achieved"], [172, 0, 73, 73, "a"], [172, 0, 75, 75, "12"]], "s": " Clustering each level by attributes that influence control flow achi \beved a 12 .\r\nNo complete linkages found.\r\nFound 15 linkages (13 had no P.P. violations) at null count 2\r\n\tLinkage 1, cost vector = (UNUSED=2 DIS=1 AND=0 LEN=23)\r\n\r\n    +----------------------------------------------------Xp-----------------\r\n    |                    +-----------------------------------Ss-------------\r\n    |                    |                   +-----------Bp----------+------\r\n    +---------Wd---------+--Ma-+-MVp-+---Jp--+-----R-----+-----RS----+      \r\n    |                    |     |     |       |           |           |      \r\nLEFT-WALL [clustering] each level.a by attributes.n that.misc-r influence.v \r\n\r\n\r\n-----------------------------------+\r\n----------------------+            |\r\n---Os--------+        |            |\r\n    +---AN---+        +----Op----+ |\r\n    |        |        |          | |\r\ncontrol.n flow.n achieved.v [a] 12 . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "Empirically, we see that clustering is applicable to CSS, and in the case of our data visualizations, unnecessary. Vectorization limit studies based on analyzing dynamic data dependencies from program traces suggest that general programs can be much more aggressively vectorized, so clustering may be the beginning of one such approach~[[CITE]].", "errors": [{"i": [175, 0, 268, 268, "vectorized"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "              \n          \n\\includegraphics[trim=0 0 0 0,clip,width=1.0\\columnwidth]{chapter6/cssspeedup4}\nB =breadth first, S = structure splitting, M = level clustering, R = nested clustering, H = hoisting, V = SSE 4.2 \n\\caption{\\textbf{Speedups from clustering on webpage layout.} Run on a 2.66GHz Intel Core i7 (GCC 4.5.3 with flags -O3 -combine -msse4.2) and does not preprocessing time.\n}\n                      \n            ", "errors": [{"i": [180, 3, 106, 212, "SSE"], "s": ["SEE", "SHE", "SUE", "USE"], "e": "spell"}, {"i": [180, 4, 93, 314, "(GCC"], "s": ["FCC", "ICC", "NCC"], "e": "spell"}, {"i": [180, 4, 128, 349, "-msse"], "s": ["muse"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "\\subsubsection{Speedup}\nWe evaluate the speedup benefits of clustering for webpage layout. We take care to distinguish sequential benefits from parallel, and of different clustering approaches. Our implementation was manual:  we examine optimizing one pass of the C3~[[CITE]] browser's CSS layout engine that is responsible for computing intrinsic dimensions. The C3 browser was written in C #, so we wrote our optimized traversal in C + + and pinned the memory for shared access.  We use a breadth-first tree representation and schedule for our baseline, but note that doing such a layout already provides a speedup over C3's unoptimized global layout. ", "errors": [{"i": [189, 1, 252, 276, "browser's"], "s": ["browsers", "browse r's", "browse-r's"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "For our experimental setup, we evaluate the same popular webpages above that rendered legibly with the experimental C3 browser.  Benchmarks ran on a 2.66GHz Intel Core i7 (GCC 4.5.3 with flags -O3 -combine -msse4.2). We performed 1,000 trials, and to avoid warm data cache effects, iterated through different webpages.", "errors": [{"i": [192, 0, 57, 57, "webpages"], "s": ["webpage", "web pages", "web-pages"], "e": "spell"}, {"i": [192, 0, 171, 171, "(GCC"], "s": ["FCC", "ICC", "NCC"], "e": "spell"}, {"i": [192, 0, 206, 206, "-msse"], "s": ["muse"], "e": "spell"}, {"i": [192, 0, 309, 309, "webpages"], "s": ["webpage", "web pages", "web-pages"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "We first examine sequential performance. Converting an array-of-structures to a structure-of-arrays causes a 10 % slowdown (B S in Figure~\\ref{fig:cssspeedup}). However, clustering each level and hoisting computations shared throughout a cluster led to a 2.1X sequential benefit (M S H). Nested clustering provided more optimization opportunities, but the compression ratio worsened: it only achieved a 1.7X sequential speedup (R S H). Clustering provides a significant sequential speedup.", "errors": [{"i": [194, 0, 55, 55, "array-of-structures"], "s": [], "e": "spell"}, {"i": [194, 0, 80, 80, "structure-of-arrays"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "Next, we examine the benefit of vectorization. SSE instructions provide 4-way SIMD parallelism. Vectorizing the nested clustering improves the speedup from 1.7X to 2.6X, and the level clustering from 2.1X to 3.5X. Thus, we see significant total speedups. The 1.7X relative speedup of vectorization, however, is still far from the 4X: level clustering suffers from randomly strided children, and the solution of nested clustering sacrifices the compression ratio.", "errors": [{"i": [196, 0, 47, 47, "SSE"], "s": ["SEE", "SHE", "SUE", "USE"], "e": "spell"}, {"i": [196, 0, 373, 373, "strided"], "s": ["stride", "strider", "strides", "striped"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "              \n          \n\\includegraphics[trim=0 0 0 0,clip,width=1.0\\columnwidth]{chapter6/csspower}\n\\caption{\\textbf{Performance/Watt increase for clustered webpage layout.}}\n                    \n            ", "errors": [{"i": [[198, 3, 17, 120, "Performance"], [198, 3, 29, 132, "Watt"], [198, 3, 34, 137, "increase"], [198, 3, 43, 146, "for"], [198, 3, 47, 150, "clustered"], [198, 3, 57, 160, "webpage"], [198, 3, 65, 168, "layout"]], "s": " Performance/Watt increase for clustered webpage layout.\r\nNo complete linkages found.\r\nFound 2 linkages (2 had no P.P. violations) at null count 4\r\n\tLinkage 1, cost vector = (UNUSED=4 DIS=0 AND=0 LEN=7)\r\n\r\n    +----------------------------------Xp----------------------------------+\r\n    +-------------Wi------------+                                          |\r\n    |             +-----COa-----+                                          |\r\n    |             |             |                                          |\r\nLEFT-WALL Performance/Watt increase.v [for] [clustered] [webpage] [layout] . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "\\subsubsection{Power}\nMuch of our motivation for parallelization is better performance-per-Watt, so we evaluate power efficiency. To measure power, we sampled the power performance counters during layout. Each measurement looped over the same webpage over 1s due to the low resolution of the counter. Our setup introduces warm cache effects, but we argue it is still reasonable because a full layout engine would use multiple passes and therefore also have a warm cache across traversals.", "errors": [{"i": [205, 1, 53, 75, "performance-per-Watt"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "In Figure~\\ref{fig:csspower}, we show a 2.1X improvement in power efficiency for clustered sequential evaluation, which matches the 2.1X sequential speedup of Figure~\\ref{fig:cssspeedup}. Likewise, we report a 3.6X cumulative improvement in power efficiency when vectorization is included, which is close to the 3.5X speedup. Thus, both in sequential and parallel contexts, clustering improves performance per Watt. Furthermore, it supports the general reasoning in parallel computing of 'race-to-halt' as a strategy for improving power efficiency.", "errors": [{"i": [208, 0, 19, 19, "csspower"], "s": ["CSS power", "CSS-power"], "e": "spell"}, {"i": [208, 0, 175, 175, "cssspeedup"], "s": ["CSS speedup", "CSS-speedup"], "e": "spell"}, {"i": [208, 0, 488, 488, "'race-to-halt'"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "              \n          \n\\includegraphics[trim=0 0 0 0,clip,width=0.6\\columnwidth]{chapter6/datarelayouttime3}\n\\caption{\\textbf{Impact of data relayout time on total CSS speedup.} Bars depict layout pass times. Speedup lines show the impact of including clustering preprocessing time.}\n                       \n            ", "errors": [{"i": [211, 3, 32, 144, "relayout"], "s": ["relay out", "relay-out", "re layout", "re-layout"], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "\\subsubsection{Overhead}\nOur final examination of clustering is of the overhead. Time spent clustering before layout must not outweigh the performance benefit; it is an instance of the planning problem. ", "errors": [{"i": [[220, 0, 15, 15, "Overhead"]], "s": " Overhead.\r\nNo complete linkages found.\r\nFound 1 linkage (1 had no P.P. violations) at null count 3\r\n\tUnique linkage, cost vector = (UNUSED=4 DIS=0 AND=0 LEN=0)\r\n\r\n[Overhead] [.] \r\n\r\n", "e": "gram"}, {"i": [[220, 1, 56, 81, "Time"], [220, 1, 61, 86, "spent"], [220, 1, 67, 92, "clustering"], [220, 1, 78, 103, "before"], [220, 1, 85, 110, "layout"], [220, 1, 92, 117, "must"], [220, 1, 97, 122, "not"], [220, 1, 101, 126, "outweigh"], [220, 1, 110, 135, "the"], [220, 1, 114, 139, "performance"], [220, 1, 126, 151, "benefit"], [220, 1, 135, 160, "it"], [220, 1, 138, 163, "is"], [220, 1, 141, 166, "an"], [220, 1, 144, 169, "instance"], [220, 1, 153, 178, "of"], [220, 1, 156, 181, "the"], [220, 1, 160, 185, "planning"], [220, 1, 169, 194, "problem"]], "s": " Time spent clustering before layout must not outweigh the performanc \be benefit; it is an instance of the planning problem.\r\nNo complete linkages found.\r\nFound 32 linkages (16 had no P.P. violations) at null count 1\r\n\tLinkage 1, cost vector = (UNUSED=1 DIS=2 AND=0 LEN=43)\r\n\r\n    +-----------------------------------------------------------------------\r\n    +-------------------------------------------------Xx--------------------\r\n    |                                                                 +-----\r\n    |        +---------------------Ss--------------------+------I-----+     \r\n    +---Wd---+--Mv--+----Pg----+---MVp---+               +--N-+       |     \r\n    |        |      |          |         |               |    |       |     \r\nLEFT-WALL time.n spent.v clustering.v before [layout] must.v not outweigh.v \r\n\r\n\r\n----Xp----------------------------------------------------------------\r\n----------------------------+                                         \r\n--------Os------------+     |                        +---------Js-----\r\n +---------Ds---------+     |      +----Ost---+      |  +--------Ds---\r\n |        +-----AN----+     +Wd+-Ss+   +--Ds--+--Mp--+  |       +----A\r\n |        |           |     |  |   |   |      |      |  |       |     \r\nthe performance.n benefit.n ; it is.v an instance.n of the planning.n \r\n\r\n\r\n----------+\r\n          |\r\n----+     |\r\n----+     |\r\nN---+     |\r\n    |     |\r\nproblem.n . \r\n\r\nPress RETURN for the next linkage.\r\n", "e": "gram"}], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "For the case of data visualization, we convert the data structure into arrays with an offline preprocessor. Thus, our data visualizations experience no clustering cost.", "errors": [], "file": "../../thesis/template/chap6.tex"}
,
{"paragraph": "For webpage layout, clustering is performed on the client when the webpage is received. We measured performing sequential two-pass clustering. Figure~\\ref{fig:cssrelayout} shows the overhead relative to one pass using the bars. The highest relative overhead was for the Flickr homepage, where it reaches almost half the time of one pass. However, layout occurs in multiple passes. For a 5-pass layout engine where we model each pass as similar to the one we optimized, the overhead is amortized. The small gap between the solid and dashed lines in Figure~\\ref{fig:cssrelayout} show there is little difference when we include the preprocessing overhead in the speedup calculation.", "errors": [{"i": [225, 0, 159, 159, "cssrelayout"], "s": [], "e": "spell"}, {"i": [225, 0, 270, 270, "Flickr"], "s": ["Flick", "Flicker", "Flicks"], "e": "spell"}, {"i": [225, 0, 277, 277, "homepage"], "s": ["home page", "home-page"], "e": "spell"}, {"i": [225, 0, 564, 564, "cssrelayout"], "s": [], "e": "spell"}], "file": "../../thesis/template/chap6.tex"}
]
